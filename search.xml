<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[datart系列03：图表插件开发]]></title>
    <url>%2F2022%2F04%2F15%2Fdatart-bi-03%2F</url>
    <content type="text"><![CDATA[概述开篇写过，datart借助自定义插件的方式，实现自定义扩展插件，就有了无限的可能。 通过最近一段时间的使用，datart自定义插件的方式同时把原来的不可能或很麻烦的二次开发变成了可能。 本身一些复杂的定制化的需求就需要独立于BI之外去做，借助自定义插件既保留的原来的灵活性，又可以抽离形成标准化，本身BI系统就是希望通过标准化来进行数据的分析展示 示例：库存01数据结构 展示效果 示例：库存02 示例：库存03数据结构 展示效果]]></content>
      <categories>
        <category>Datart</category>
        <category>可视化工具</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Datart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[datart系列02：图表插件开发作品]]></title>
    <url>%2F2022%2F04%2F05%2Fdatart-bi-02%2F</url>
    <content type="text"><![CDATA[概述今天整理了两个为未能参赛的作品，个人感觉还是比较好的两个点，就索性整理发出来。 作品：手绘风格（D3）这个上一篇中说到了，也是时间的问题，未能找到原因，本以为是iframe嵌套导致的，后来官方给了去掉iframe的配置的方法进行了尝试，发现不是这个原因。 其实到现在也没有完全定位不能正常的渲染的原因，今天就换了种实现方式，放弃直接用开源的轮子，直接写源代码到插件里面，发现能够正常展示了，后续在把其它图表的补充完整。效果如下： 作品：3D地图（CesiumJs）关于Threejs、WebGL、CesiumJs这里不做赘述，虽然CesiumJs受众相对较小，而且偏重GIS，但是利用cesiumjs做数字孪生应该也有很多了，所以就集成到datar插件试一下，而且CesiumJs号称永久开源免费，但是这个完全不在参赛作品计划内，原因很简单，用到了付费插件，虽然费用很低，做项目没有任何问题，但是参赛开源就不好了。但是CesiumJs作为datart插件集成还是很简单的，单纯的3D地球，肯定满足不了实际场景，但是花点实际研究研究API搞点特效出来，还是不难的，而且CesiumJs好用，效果出众，下面就看一下效果：]]></content>
      <categories>
        <category>Datart</category>
        <category>可视化工具</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Datart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[datart系列01：图表插件开发作品大赛]]></title>
    <url>%2F2022%2F03%2F27%2Fdatart-bi-01%2F</url>
    <content type="text"><![CDATA[概述2022年的第一篇，最近疫情+航空事故，虽是春暖花开，还是宅在家开码。借着datart图表插件开发作品大赛，给开了个头，datart的头，写作的头，但愿后续多写，今年估计的写的方向也会比较分散。 这一篇就当是参加图表插件开发作品大赛的一次开篇总结，也算是预热，这次采用datart自定义插件的形式，全部用自定义插件的方式，不改动源代码，不管怎么说，datart自定义插件发现越用越丝滑，很看好这一特性。后续再写datart源码及二次开发。 作品：作品1：海洋鱼馆（动画）这个作品算是魔改，但确实有着特殊的应用场景 这个在Davinci的时候做过扩展，这次全新的素材 造了鱼馆的轮子来适配datart的插件，后期我们再展开思路讲实现，并开源出来（包括素材） 作品2：地图（echarts）这个也在Davinci扩展了，这次也是做了集成，场景没什么好说的，直接看效果，这个本来也想套一层封装，发现有点问题，直接用原生js做的集成 作品3：智能仓库（threejs）智能数字化车间，3D车间模型等等，这种3D场景化很多人都追求，甚至是偏执。查了资料，看了Threejs官网所有的demo，逛了社区，确实没找到高大上且合适的场景化模型。就从网上找了个智能仓库的场景做了集成，个人理解这种3D场景就是先做场景化的模型（这种模型确实需要专业人来做，上手有门槛），在场景位置上展示数据或者图表。这个也是造了适配datart的轮子，算是个demo，半成品吧，后期展开讲，也开源出来，有专业水平的可以做模型然后集成到datart。 作品4：手绘风格（D3）这个效果没做成功，在Davinci的时候因为受限于echarts就没有做，这次可以扩展D3，本以为这个应该是最简单，确没有成功，初步判断应该是iframe嵌套导致滤镜不成功，没找到合适的方案。不过除了滤镜D3其它的效果集成还是没有任何问题的，后续再研究。 总结：总结一下datart自定义插件，对于前端来说可能算不上新技术，但是对于BI来说就是很好一次微创新： 特殊化定制，满足个性化需求 上手容易，官方这块文档很详细 扩展灵活，很丝滑 像D3这种灵活性很高的，本是就具备无限可能，所以datart也具备无限可能]]></content>
      <categories>
        <category>Datart</category>
        <category>可视化工具</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Datart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2021年新Mac设置]]></title>
    <url>%2F2021%2F11%2F27%2Fmac-01%2F</url>
    <content type="text"><![CDATA[看到SHAWN @SWYX WANG的My 2021 New Mac Setup的文章，相同的是都是用Mac作为程序开发，因此借着我的新Mac，我也进行了整理，写下这一份整理笔记。 系统设置这个根据个人不同的喜好 修复触控板方向：触控板 -&gt; 滚动和缩放 - 自然关闭 禁用 Spotlight 搜索除应用程序和系统首选项之外的所有杂项 禁用询问 Siri 禁用字典查找：触控板 -&gt; 指向和点击 -&gt; 查找和数据检测器关闭 首选项 → 显示文件扩展名 从 程序坞（Dock） 中删除所有内容，除了：Finder、系统偏好设置和垃圾箱 启用三指拖移：辅助功能 -&gt; 指针控制 -&gt; 启用拖移。（备注：启用后原三指操作变为四指） 浏览器设置Chrome自然必不可少，下载安装即可，设置为默认 扩展程序： Morpheon 黑暗主题 React Devtools Vue.js devtools GitHub-Chart go get for Github Markdown Nice Octotree - GitHub code tree Sourcegraph 终端设置命令行真的是程序员必备的了，这个终端就很重要了，Mac的终端默认是bash，这个可真是太bash了，连ll命令都不行，当然可以配置。还是不推荐bash（就像window下的cmd，宁愿选择git下的bash），这个确实没法让我们起飞。 备注：bash就是shell一种增强版本，就是经常在sh文件里看到的#! /bin/bash shell有很多种，常用的基本上就是bash、zsh、fish了，他们的区别无外乎就是命令、格式（包括高亮、特殊格式显示）、提示信息等方面上的区分。 可以先看一下Mac提供了哪些shell（可以直接到bin目录下看），可以通过偏好设置就像修改，也可以直接通过下面的命令设置，设置完成需要重新进入终端 12345678910# 查看所有的shellcat /etc/shells# 查看系统用户默认shellcat /etc/passwd | grep sh## 系统默认的终端为bash，切换该终端为zshchsh -s /bin/zsh# 切回默认终端bashchsh -s /bin/bash# 切换终端fishchsh -s /bin/fish 没有需要安装，这里我安装的zsh而且是Oh My Zsh，安装简单，直接看官网。 Oh My Zsh可以设置主题和插件，提示信息非常nice，详细配置不再赘述，我摘了一段和zsh的区别： 1# Zsh 是一个shell，就像bash或fish 一样，它解释命令并运行它们。Oh My Zsh 是一个构建在 zsh 之上的框架，其结构允许它拥有插件和主题，并从一开始就提供我们认为最好的设置。您可以在没有 Oh My Zsh 的情况下使用 zsh，但如果您没有 zsh，则无法使用 Oh My Zsh。 如果需要fish的，推荐阮一峰的文章：Fish shell 入门教程 超级终端（Hyper Terminal）Hyper Terminal，一个通用的串行交互软件，可以通过串口、调制解调器或以太网连接，使用该程序连接到其他计算机、Telnet 站点、公告板系统 （BBS）、联机服务和主机、嵌入式系统等。 超级终端还能对外观进行主题设置并可以安装插件，配置直接通过修改.hyper.js即可。 环境及应用程序安装关闭SIP关闭SIP（SIP 全称为「System Integrity Protection」即「系统完整性保护」）还是有必要的，关闭之后才能修改某些文件的权限，一般建议修改完再打开，长期关闭回更方便，即使有些软件sudo进行安装也可以，还是关闭了吧。 以前的快捷键Command+R进入到恢复模式，M1芯片直接按住电源按钮即可进入。 顶部菜单拉中打开终端，输入： 1csrutil disable 然后重启，设置权限就可以了 123sudo chmod -R 777 目标文件夹或者sudo chmod a+w 目标文件夹 Homebrew安装： 1/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 如果443，修改host文件 123sudo vi /etc/hosts# 加入199.232.4.133 raw.githubusercontent.com 或者使用国内源 使用国内源： 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 配置的中科大的资源 jdk官网下载安装（1.8），默认不需要配置环境变量 maven官网下载最新版，解压配置环境变量即可 1234 // vi ~/.bash_profileexport MAVEN_HOME=/Users/bao/software/apache-maven-3.8.4export PATH=$PATH:$MAVEN_HOME/bin git1234brew install gitgit --versiongit config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot; nodejs直接安装 12 ~/ brew install node ~/ node -v 但是实际工作会涉及到多node版本的问题，建议还是用n或者mvn来管理，这里我们用n，个人感觉好用轻巧 123456789 ~/ brew install n ~/ n stable // 安装最新稳定版 ~/ n 14.17.0// 历史版本地址：https://nodejs.org/zh-cn/download/releases/ ~/ n ls // 列出所有版本node/14.17.0node/16.13.0 ~/ n // 切换版本 ~/ n rm &lt;version&gt; // 删除某个版本 如果已经安装了，node卸载方法 验证 12 ~/ which node/User/&lt;your&apos;s-user-name&gt;/.nvm/versions/node/&lt;latest-node-lts-version&gt;/bin/node 卸载 1 ~/ rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125; IntelliJ IDEA （v2021.2.3）官网下载，需破解 VSCode官网下载即可，简单 其它 Redis Desktop Manager（需破解） Navicat Premium 15（需破解） UltraEdit（需破解） FinalShell 其它应用 CleanMyMac X （电脑清理、破解版） WPS Office 超级右键 iShot（截图工具） Typora（Markdown编辑工具） AppDelete（软件卸载、破解版） Photoshop Parallels Desktop（Linux、win11、破解版） MindNode（思维导图） 最后一游Wonderbox]]></content>
      <categories>
        <category>MacBook</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序：Painter画布]]></title>
    <url>%2F2021%2F08%2F03%2Fwx-painter%2F</url>
    <content type="text"><![CDATA[Painter这个小程序画布组件应该很多人在用，github上超3K的star就已经说明这个组件的强大了。这里我们用这个组件实现短讯（如24小时动态）的分享和海报生成。 效果 图二生成的图片，也是分享出去的效果，可以点击分享跳转到短讯的详情即可，分享到群如下： 介绍Painter组件地址：https://github.com/Kujiale-Mobile/Painter 可以通过源代码看一下组件的实现方式，其实Painter的readMe里面已经把组件的实现方式描述的很详细了，组件接收json格式，然后通过pen.js（画笔）画出json格式不同类型（文本、图片、矩形、qrcode ）的view绘制，这种方式设计巧妙，对于很多复杂的情况需求都能满足。而且代码完善，优化调整也很方便。 Painter提供的工具能够将json数据直接转换效果，方便调试，链接地址： 链接1：https://painterjs.github.io/ 链接2：https://lingxiaoyi.github.io/painter-custom-poster/ 我们上面短讯的效果，只需利用Painter封装两个组件，一个用于分享，一个用于生成海报，控制两个组件显示隐藏即可。通过按钮传递标题、时间、标签、内容等信息，并通过组件接收，然后拼装json文件传递给Painter组件。 12345&lt;!-- 分享绘图组件 --&gt;&lt;share-box wx:if=&quot;&#123;&#123;isCanDraw&#125;&#125;&quot; isCanDraw=&quot;&#123;&#123;isCanDraw&#125;&#125;&quot; time=&quot;&#123;&#123;timeShare&#125;&#125;&quot; source=&quot;&#123;&#123;sourceShare&#125;&#125;&quot; id=&quot;&#123;&#123;idShare&#125;&#125;&quot; title=&quot;&#123;&#123;titleShare&#125;&#125;&quot; content=&quot;&#123;&#123;contentShare&#125;&#125;&quot; bind:close=&quot;handleClose&quot; bind:initData=&quot;initData&quot; bind:createPoster=&quot;createPoster&quot;/&gt;&lt;!-- 海报组件 --&gt;&lt;poster-box isPoster=&quot;&#123;&#123;isPoster&#125;&#125;&quot; time=&quot;&#123;&#123;timeShare&#125;&#125;&quot; source=&quot;&#123;&#123;sourceShare&#125;&#125;&quot; id=&quot;&#123;&#123;idShare&#125;&#125;&quot; title=&quot;&#123;&#123;titleShare&#125;&#125;&quot; content=&quot;&#123;&#123;contentShare&#125;&#125;&quot; bind:closePoster=&quot;handleClosePoster&quot;/&gt; 此外，我们利用lin-ui实现了日期的吸顶效果（备：lin-ui对于吸顶效果的封装很易用，可以尝试一下）、内容展示的卡片效果，不再赘述，详细实现可直接查看下面的代码地址。 代码 已提交github，扫码关注公众号（diss带码），回复：webview，获得源码github地址]]></content>
      <categories>
        <category>小程序</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序：mqtt+webview控制显示内容]]></title>
    <url>%2F2021%2F07%2F22%2Fwx-mqtt%2F</url>
    <content type="text"><![CDATA[看到mqtt+webview似乎不知道能做什么，mqtt微消息服务更适用iot物联网，这个应该熟悉，但是似乎还是得从webview说起。webview的场景不仅仅是手机端的APP或者小程序用到，好多基于android主板显示的设备、大屏等webview都发挥了很大的作用。这里我们一是验证小程序的mqtt，二是通过mqtt控制设备自动切换显示内容，这样试想一下，其实就是远程操控设备显示内容的一种很好的方式。 效果 mqtt小程序端需要mqtt.js客户端库：https://github.com/mqttjs/MQTT.js 小程序配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const app = getApp()var mqtt = require(&apos;../../../utils/mqtt.min&apos;)var client = nullPage(&#123; /** * 页面的初始数据 */ data: &#123; webUrl: &apos;https://www.baidu.com&apos; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.connnectMqtt() &#125;, connnectMqtt: function ()&#123; var that = this const options = &#123; connectTimeout: 4000, // 超时时间 clientId: &apos;mqtt_&apos; + Math.random().toString(16).substr(2, 8), port: 8083, //重点注意这个坑 &#125; client = mqtt.connect(&quot;wx://xx.xx.xx.xx/mqtt&quot;, options); client.on(&apos;reconnect&apos;, (error) =&gt; &#123; console.log(&apos;正在重连:&apos;, error) &#125;) client.on(&apos;error&apos;, (error) =&gt; &#123; console.log(&apos;连接失败:&apos;, error) &#125;) client.on(&apos;connect&apos;, (e) =&gt; &#123; console.log(&apos;成功连接服务器&apos;) //订阅一个主题 client.subscribe(&apos;test&apos;, &#123; qos: 0 &#125;, function(err) &#123; if (!err) &#123; console.log(&quot;订阅成功&quot;) &#125; &#125;) &#125;) client.on(&apos;message&apos;, function (topic, message) &#123; console.log(&apos;received msg:&apos; + message.toString()); that.setData(&#123; webUrl: message.toString() &#125;) console.log(that.data.webUrl) &#125;) &#125; &#125;) 1&lt;web-view src=&quot;&#123;&#123;webUrl&#125;&#125;&quot; bindmessage=&quot;getmessage&quot;&gt;&lt;/web-view&gt; mqtt服务端安装EMQ X 是一款完全开源，高度可伸缩，高可用的分布式 MQTT 消息服务器 git地址：https://gitee.com/emqx/emqx docker安装步骤1$ docker search emqx // 查看版本 1$ docker pull emqx/emqx // 拉取镜像 1$ docker run -dit --name emqx -p 18083:18083 -p 1883:1883 -p 8083:8083 -p 8084:8084 emqx/emqx:latest // 运行 1$ docker exec -it emqx /bin/sh // 进入命名 web管理界面http://127.0.0.1:18083 #账号： admin #密码: public 端口介绍1883：MQTT 协议端口 8883：MQTT/SSL 端口 8083：MQTT/WebSocket 端口 8080：HTTP API 端口 18083：Dashboard 管理控制台端口 mqtt客户端工具我们没必要写后台代码，直接用个mqtt客户端工具做测试，用的MQTTX，这个就根据个人习惯选了 MQTTX地址：https://github.com/emqx/MQTTX/releases 安装完成配置验证即可。 代码 已提交github，扫码关注公众号（diss带码），回复：webview，获得源码github地址]]></content>
      <categories>
        <category>小程序</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序：webview + PDF预览]]></title>
    <url>%2F2021%2F07%2F20%2Fwx-pdf%2F</url>
    <content type="text"><![CDATA[一般文件预览除了图片基本主要指office的文件预览，不同文件（word、Excel、pdf）格式差异大，所以很难有共性。相对来说PDF的预览会相对简单一些，而且大都能转换成pdf，我们就已pdf为例。小程序官方未提供，目前能找到和想到的方式，如下： 第一：采用wx.openDocument123456789101112wx.downloadFile(&#123; url: &apos;www.file.com/file.ppt&apos;,//可以是后台传过来的路径 success: function(res) &#123; const filePath = res.tempFilePath wx.openDocument(&#123; filePath: filePath, success: function(res) &#123; //成功 &#125; &#125;) &#125;&#125;) 效果： 说明：这种实际上是先下载了临时路径，好处是pdf、word、Excel都能预览，坏处是这种方式不一定能接受。 第二：webview+第三方pdf库pdfjs是个很好的pdf预览的js库，可以不用改造直接使用，简单部署个服务，或者通过nginx配置一下即可，这里我们直接通过cdn阿里oss文件服务器来运行 pdfjs获取地址：https://github.com/mozilla/pdf.js oss服务demo： 1https://byfile.disscode.cn/pdfjs-2.8/web/viewer.html?file=https://byfile.disscode.cn/blog/2021/wx/pdf/01.pdf 小程序配置就很简单了，就是通过webview的方式调用pdfjs服务，只需传递pdf文件地址即可 1&lt;web-view src=&quot;https://byfile.disscode.cn/pdfjs-2.8/web/viewer.html?file=&#123;&#123;url&#125;&#125;&quot;&gt;&lt;/web-view&gt; 备注：PDF.js访问远程服务器（非同域名下）报file origin does not match viewer’s 需要将pdfjs下面的viewer.js中注释掉代码 123// if (origin !== viewerOrigin &amp;&amp; protocol !== &apos;blob:&apos;) &#123;// throw new Error(&apos;file origin does not match viewer\&apos;s&apos;);// &#125; 第三：延伸markdown文件渲染markdown格式的内容渲染已有组件可以支持，尝试markdown的文件直接进行渲染，这里直接找到第三方库marked.js进行尝试 github地址：https://github.com/markedjs/marked 同样制作oss服务的demo 1https://byfile.disscode.cn/marked/marked.html?file=https://byfile.disscode.cn/blog/2021/wx/mk/%E3%80%90BLOG%E3%80%91hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B.md 小程序同样是webview的方式： 1&lt;web-view src=&quot;https://byfile.disscode.cn/marked/marked.html?file=&#123;&#123;url&#125;&#125;&quot;&gt;&lt;/web-view&gt; 但是，markdown采用这种方式直接渲染文件，发现图片、换行等样式渲染还是有问题的，所以期待更多尝试。 备注：测试去掉域名的校验，要么就添加到小程序业务域名里面，否则不能正常访问 第四：代码 已提交github，扫码关注公众号（diss带码），回复：webview，获得源码github地址]]></content>
      <categories>
        <category>小程序</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序：数十年Lite]]></title>
    <url>%2F2021%2F07%2F17%2Fwx-ssn%2F</url>
    <content type="text"><![CDATA[概述端午参加毕业十周年聚会，聚会之前花了几天时间撸了个小程序，聚会结束了，十年也真的过去了。 效果 组件介绍ColorUI很棒的小程序UI，而且很大一个特点是特别的简洁，组件也很完善 github地址：https://github.com/weilanwl/ColorUI/ 效果地址：http://demo.color-ui.com/ Painter这个用来生成图片、海报确实好用 github地址：https://github.com/Kujiale-Mobile/Painter 菊码 代码 已提交github，扫码关注公众号（diss带码），回复：数十年，获得源码github地址 备注：后端采用springboot + MongoDB，源码已去除后端，可以直接运行，数据目前读取的json文件 温馨提示：发布动态（上传图片）功能涉及个人小程序审核就去掉了，但是可以当成后台工具，要么就单独做个后台管理的web端]]></content>
      <categories>
        <category>小程序</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证码：五福临门]]></title>
    <url>%2F2021%2F03%2F05%2Fbless-01%2F</url>
    <content type="text"><![CDATA[一看验证码这个既熟悉又常用的功能，一提起来你就会想起各种各样的验证码，一个偶然的机会，就冒出来做个验证码，慢慢的就演变成现在的五福临门验证码。先看一下效果图： 由来 春节前看到一篇关于验证码的文章，动态刷新、滑动验证，这里的动，总感觉没有“动” 加上之前做的游鱼，就想让它动起来，所以最初就是在滑块验证码的基础上，让滑块在外面游动起来 后来支付宝集五福，让我突然感觉可以考虑，五个福字随机掉下来一个在外面游动，然后滑动原位置，正好符合春节的气息 再后来参与了支付宝打印福字的活动，然后就手写了五福，这样不仅是随机五福，还可以随机不同主题的五福了 春节前开始的，前期做了技术验证，春节陆陆续续进行了实现 后来找资料做轨迹校验，断断续续，今天暂时把前端部分发出来，后端验证决定后续再补一篇 下面是个设计效果图： 认知验证码虽然已经司空见惯了，但是还是想讲一下验证的一些接触，从中也能体会乐趣。 起初进入技术行业，还是一个验证码不流行的阶段，计算机识别技术更是起步，所以扭曲、污染的文字无法辨识，所以最初见到的就是4个字母数字，一条飞线。 慢慢的越来越流行，越来越多样，越来越看不懂 越来越烧脑，亦或是恶搞 新时代的验证码越来越多样，出现了两极分化，一种让你赏心悦目，一种让你抢不到票 验证码在技术里面或许是小场面，但却蕴藏着大智慧，而且是紧跟时代的产物，根据人们需求的变化而变化，当然破解和识别技术的提升也在嘶声呐喊和“催更” 技术验证码可以防止：恶意破解密码、刷票、论坛灌水等 软件包：成熟的插件和软件包，直接引入使用就可以了 第三方：网易易盾等，购买按官方文档使用 网易易盾：https://dun.163.com/ 无痕验证：阿里云-人机验证 https://help.aliyun.com/product/28308.html 用过阿里云的都知道，阿里云登录输入账号密码就可以了，点击登录也没有多余的操作，以为就没有验证，其实阿里做的是无痕验证，即使没有可视化的验证码出现，其实已经对你登录做了人机的校验了，所以不要以为没有可见的验证码就误以为没有验证。 实现技术栈：前端nodejs+vue，后端java+redis 滑块验证：vue-drag-drop 游动：animateplus 目前的前端部分演示demo（目前只支持pc端）：http://bless.disscode.cn/#/loginSlider 五福临门一曰寿，二曰富，三曰康宁，四曰攸好德，五曰考终命 五福含意：第一福是“长寿”、第二福是“富贵”、第三福是“康宁”、第四福是“好德”、第五福是“善终”。有人简称为寿富康德善。]]></content>
      <categories>
        <category>验证码</category>
      </categories>
      <tags>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源论坛：社区选择Discourse]]></title>
    <url>%2F2021%2F03%2F02%2Fdis-01%2F</url>
    <content type="text"><![CDATA[回想以往逛论坛、贴吧的年代，似乎渐行渐远，现在人类追求的多样性超出想象，但论坛并未走下神坛，只是换了一种或者是以多种方式存在。社区、小组、圈子等都有更多的载体和工具，今天就说一下开源论坛discourse。 Discourse应该也已经20多年了，并不新鲜，也是因为平常经常浏览的技术社区用的就是discourse，所以就搭建一下，深入感受一下discourse，以备后用。 Discourse总体下来，觉得挺适合做社区，尤其是技术性比较聚集的论坛 开源论坛 创始人想要让改变十年未变的互联网论坛模样 基于Ruby on Rails 和 Ember.js 开发，数据库使用 PostgreSQL 和 Redis 最大的特点是简洁和专业性，以话题为关系聚集用户 Discourse官网： 官方网站：https://www.discourse.org/ 官方社区：https://meta.discourse.org/ Github项目：https://github.com/discourse/discourse 搭建步骤安装git和Docker12apt-get install gitwget -qO- https://get.docker.io/ | sh 安装Discourse1234mkdir /var/discoursegit clone https://github.com/discourse/discourse_docker.git /var/discoursecd /var/discoursecp samples/standalone.yml containers/app.yml（or ./discourse-setup 初始化） 修改配置文件123456789vim containers/app.ymlUNICORN_WORKERS（如果是1Gb内存就是2，2GB内存以上就是3-4）DISCOURSE_DEVELOPER_EMAILS管理员邮箱DISCOURSE_HOSTNAME 绑定的域名DISCOURSE_SMTP_ADDRESS是邮局服务器DISCOURSE_SMTP_PORT是SMTP的端口DISCOURSE_SMTP_USER_NAME账号DISCOURSE_SMTP_PASSWORD密码 特别注意的是：端口号465是没有效果的 1DISCOURSE_SMTP_PORT: 587 以上配置完了，会收不到邮件有两种方式修改 第一种：用官方的工具launcher创建管理员账号 123cd /var/discourse./launcher enter apprake admin:create 创建管理员账号，按要求输入管理员邮箱和登录密码 登录网站，用刚才创建的账号直接登录。 在settings页面设置notification email为发件邮箱，就是之前配置文件里面写的那个邮箱。 在邮件测试页面发一封测试邮件，应该测试成功了。 第二种：编辑发件邮箱 12345vim containers/app.yml//定位文件底部，打开注释- exec: rails r &quot;SiteSetting.notification_email=&apos;xxx@qq.com&apos;&quot;//重新build一下./launcher rebuild app 修改完成后，重新构建1./launcher rebuild app nginx与discoursediscourse配置修改： 12cd /var/discoursevim containers/app.yml 修改：(设置端口代理) 12expose: - &quot;9090:80&quot; # http 最后运行 1./launcher rebuild app nginx增加配置：增加discourse.conf即可 添加Github第三方登录打开Github application，进入Developer applications，新建应用程序 Homepage url为你的discourse地址，authorization callback url为你的discourse地址加上/auth/github/callback，然后复制Client ID和Client Secret，最后打开discourse，进入管理－设置－登录，找到下图所示三个字段，勾选填入刚才复制的内容 然后确定、完成。 点击=&gt;完成！ 常见问题计算技术论坛关于discourse的问题：https://www.ossez.com/search?q=discourse 其它体验了一下Discourse的管理界面和可配置的操作，后台支持定制化的配置和插件化，而且确实很简洁，并能够提供对外API，有时间可以继续探究 我的discourse地址：https://lt.disscode.cn/]]></content>
      <categories>
        <category>discourse</category>
      </categories>
      <tags>
        <tag>discourse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛年开篇：网站拜年]]></title>
    <url>%2F2021%2F02%2F24%2Fweb-niu%2F</url>
    <content type="text"><![CDATA[牛年开篇：网站拜年开启新年第一篇，本应该在春节假期完成，趁着马上元宵节，就以此开篇。 重新调整了一下个人网站，来个新年新气象，也希望牛年牛转乾坤，更上一层楼。 力求简单，做几点要求： 个人网站，我们还是区分一下企业和产品网站 前端展示，先不牵扯后端，当然也是为了快速部署 新年元素、牛元素 兼容手机端 达成几个目的： 迎接新的一年 宣传，似乎这个是必不可少，即使没有什么可宣传的内容 github网络的限制，导致博客受限，同时选择了简书，后期考虑通过网站，进而做调整 服务器的充分利用 网站地址：https://disscode.cn 建站方式 服务器：云服务器，扩展性、灵活性高（推荐） 虚拟主机：这个的经济优势很明显 第三方：快捷建站网站 域名无论何种方式，有个自己的域名这个是最好的、也算是必须的，申请渠道很多，申请一个即可（备注：需要备案） ssl证书ssl证书其实是挺贵的，但是可以用免费的，ssl证书其实对于网站来说也是必不可少的，没有证书的网站就感觉别扭 推荐免费证书： Let’s Encrypt ohttps 阿里云、腾讯云等 网站代码技术栈：nodejs + react 找了一些网站，最好选了个开源的网站代码，推荐一下，记得点赞 github地址：https://github.com/ArthurYung/react-my-website 发布如果是服务器，采用Nginx来部署就很简单了]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github自定义主页秀]]></title>
    <url>%2F2020%2F09%2F03%2Fgithub-custom-home%2F</url>
    <content type="text"><![CDATA[github自定义主页秀 ​ github支持自定义主页已经有一段时间了，今天尝试了一下。详细教程可以从网上搜索一下，比较简单，也可以直接到我的github（下面有链接）复制一下，记得点赞奥。 😎 秀一秀 🔨 创建​ 很简单，创建与github账号同名公开的仓库，并初始化README.md，完成 🔧 美景​ 每日刷新或者随机（自己去选对应的类型的api） ​ https://api.lyiqk.cn/ ​ 备注：github由于缓存了图片，不会每次都刷新 ​ 建议用必应每日一图：https://api.lyiqk.cn/bing 🔑 我的自定义主页​ 连接地址：https://github.com/dumplingbao/dumplingbao ​ 备注：由于是markdown格式，预览效果与实际展示有所不同]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列08：mongoDB（JDBC查询）四种解决方案]]></title>
    <url>%2F2020%2F08%2F24%2Fdavinci-dev-mongo%2F</url>
    <content type="text"><![CDATA[​ 关于Davinci使用mongoDB的问题，就一直没有断过。我们不管怎么评价mongoDB，似乎年轻的mongoDB俨然是主流数据库了。而且现在对于BI来说能不能支持主流的NoSQL数据库，已经成为一个很重要的衡量标准。目前BI通过JDBC的方式访问NoSQL数据库还是首选，但是mongo官方未提供JDBC驱动包，这里介绍四种mongo-JDBC查询数据的解决方案：（备注：mongo-JDBC问题不仅限于Davinci，也不限于BI，一些实际应用中也会碰到） 序号 方案 备注 综述 1 利用presto连接 facebook开源SQL查询引擎 优点：开源、免费、兼容性良好缺点：需要单独部署服务 2 1、unityjdbc破解版2、unityjdbc试用版 商业化产品 优点：集成简单、不需要单独部署缺点：收费、_id字段值不显示试用版本地mongo支持需要解决破解版只能简单的查询、子查询等有问题，存在问题比较多 3 mongo-bi连接器 mongo官方 优点：官方出品、免费、兼容性极好缺点：需要单独部署服务推荐用此方式 4 开源手写驱动包 开源 优点：灵活性可控缺点：成本高、耗精力 利用presto连接​ Presto是一个facebook开源的分布式SQL查询引擎，而且支持跨库查询，当然也支持mongoDB，Davinci通过presto做类似的桥接，然后也能实现mongoDB的jdbc查询，如果公司使用presto，采用这种方案也是不错的选择，兼容性可以。 ​ 这里我们重点介绍后面两种，没有实际进行尝试，大家可以尝试一下，简单介绍一下步骤： ​ 第一：首先需要安装presto-server服务，看好版本，支持MongoDB的才可以 ​ 第二：配置mongodb.properties 123connector.name=mongodbmongodb.seeds=ip:portmongodb.schema-collection=admin ​ 第三：Davinci配置数据源 ​ jdbc:presto://ip:port/mongodb/test ​ 第四：view实现JDBC查询 ​ select * from mongodb.数据库名.集合 unityjdbc​ 由于unityjdbc是收费的，这里我们用网上的破解版和试用版都试一下。 官方试用版​ 第一：试用版，去官网unityjdbc下载JDBC Driver for MongoDB，这里我们用的是``这个版本下载地址：http://www.unityjdbc.com/download.php?type=mongodb ​ 第二：下载下来的UnityJDBC_Trial_Install.jar 需要java -jar安装，安装完获取unityJdbc.jar（或者mongodb_unityjdbc_full.jar这个jar包也可以） ​ 第三：mongodb-driver的依赖默认是注释掉的，将注释去掉，并将unityJdbc.jar引入到工程里面或者复制进去，在porm里面引入本地依赖 123456789101112&lt;!--mongodb --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;unityjdbc&lt;/groupId&gt; &lt;artifactId&gt;unityjdbc&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/unityjdbc.jar&lt;/systemPath&gt;&lt;/dependency&gt; ​ 第四：Davinci配置数据源（强调一下，我用官方的包，连接本地mongo报hostname的错误，就先用官方的测试库） jdbc:mongo://localhost:27017/数据库 官方测试地址 jdbc:mongo://ds029847.mongolab.com:29847/tpch 创建view(_id不能正常显示） 创建widget 子查询 关联查询 网传破解版试了一下分享出来的破解版，除去上面的安装步骤，直接引入即可 创建数据源，这个包比试用版好的是本地mongo能直接使用 jdbc:mongo://localhost:27017/数据库 创建view（_id不显示、集合列表不显示） 创建widget 从错误上来就不能很好的兼容，子查询关联查询更是不能正常使用 mongo-bi连接器​ mongo官方没有提供mongo的JDBC驱动，但是提供了mongo-bi-connector，允许使用所选的BI工具通过标准SQL查询对MongoDB数据进行可视化。 ​ 搜了一下资料，BI Connector 可以使用 SQL 或 ODBC 数据源方式直接访问 MongoDB，MongoDB 早期版本直接使用 Postgresql FDW 来实现 SQL 到 MQL 的转换，后来实现更加轻量级的 mongosqld 来支持 BI 工具的连接。这里我们就尝试一下mongosqld，来验证一下。 下载并安装mongo-bi-connector​ 官方下载：https://www.mongodb.com/try/download/bi-connector，支持windows、linux版本 ​ 默认安装即可 配置文件​ 默认配置即可，如果有mongo做了限制，或者调整端口，修改mongosqld-config.yml，详细配置看官网 12345678910111213net: bindIp: &quot;127.0.0.1&quot; # To bind to multiple IP addresses port: 3307 mongodb: net: uri: &quot;mongodb://127.0.0.1:27017&quot; ssl: enabled: false auth: username: xxx password: xxx source: xxx mechanism: SCRAM-SHA-1 启动mongosqld​ 我使用的windows版本双击mongosqld.exe运行即可 maven引入依赖包123456789101112&lt;!-- 这个包必须有 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 非必须，这个是JDBC认证插件，如果你做测试或者你的mongo本身在裸奔，就没必要了 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.42&lt;/version&gt;&lt;/dependency&gt; 创建数据源备注：这里使用mysql即可 创建view（_id和集合列表均正常） 创建widget 子查询 关联查询 开源手写驱动包​ 这个绝对是一个解决方案，其实工作中就会封装mongo的一些比如关联查询类似的组件，写这个驱动包也未必没有优势，我觉着如果上面的方案兼容sql的场景如果存在问题，那么自己写的驱动包改造就容易的多，第三方的包就没那么好改了。 ​ 这里推荐一个mongo的JDBC开源驱动包，如果有自己想写的想法仅供参考。 ​ 连接：https://gitee.com/f4haofeng/mongodb-jdbc/tree/master/src/main/java/com/mongodb 综上所述​ 其实，表格里面已经比较了，根据个人需求选择即可，还是推荐使用mongo官方的BI连接器的方式，虽然我们没有对性能进行比较，但从使用性、兼容性、子查询、关联查询等方面比较，BI连接器的方式完全能够胜任。 交流学习学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列07：BI新元素尝试]]></title>
    <url>%2F2020%2F08%2F20%2Fdavinci-dev-newel%2F</url>
    <content type="text"><![CDATA[​ 忙于工作，停更很长时间了，最近继续开搞，先写此一篇。生活犹如演绎，写作算是解说，先看效果： ​ 由来​ 想在BI里面引入一些别具一格的新元素，这个想法由来已久，本来是想做下面的这种效果： ​ 这个是chart.xkcd 手绘风格图表库，我之前写过一篇介绍，详细介绍可以查看手绘风格的图表库（char.xkcd），可是由于davinci采用的是echarts，通过尝试未找到合适的很好的解决方案，只能暂时搁置了。 ​ 所以先做了这个鱼馆的场景，缘起于之前做过的项目，类似于一个积分系统，从积分到最终呈现单独做的。试想一下，如果有这样的BI工具，支持这样的场景，也就能根据数据快速生成，所以这样想，需求、场景都是有的，就尝试在BI里面集成这种鱼馆的效果，也算给BI的一种新的元素。 技术选型​ 技术点在动画选型上，后端不需要操作，这里我们推荐几种技术实现 jQuery：之前就是用jQuery实现的，完全没有问题，就是代码量看上去比较繁琐 lufylengend：这是个h5的引擎，简单、功能强大，有兴趣可以了解一下，用于实现这个功能偏重，但是后续考虑增加一些特性会比较方便，功能没得说。 animate相关的npm包： ​ 1、animate-npm：这个包有点像被抢注了，功能实在简单，简单到看上去就不是你想要的 ​ 2、bendc/animate：这个是个封装的js文件，是6年前开发的了，完全够用，操作方便 ​ 3、bendc/animateplus：这个包和上一个是一个作者，一看就是升级版，也已经开发有3年了，支持npm直接安装 ​ 这里我们用的bendc/animateplus，也可以尝试其它的，我们用到的动画只是简单的，不需要复杂的功能，更不需要复杂的算法。这里特别强调一下，这个本身就是开源的封装，没有完整的api，知识盲点会导致需要不断的尝试才行。 功能点介绍 序号 功能 备注 1 数据模型 一个维度，一个指标，示例：用户和积分 2 主题 鱼馆背景可切换，海洋元素一些引入 3 速度 速度可设定 4 积分等级 目前固定，通过积分判断区间和对应的等级及动物 5 信息展示 默认展示维度信息，如用户及积分信息 背景切换 速度切换 显示指标单击显示指标信息，再次单击隐藏指标信息，我们也不提倡排名看分就隐藏 示例数据结构 积分等级处理​ 这里效果图是随机取的动物，正常配置通过积分判断所处的等级和对应的动物，目前是静态的配置文件，后续也应该是可配置化。 交流学习学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。 备注：技术选型尝试多次，每个都有各自的优缺点，就会有所取舍，亦或者不能完全深入了解，这次BI里面加入这种非常规的东西也算是一种尝试，欢迎进群交流，留言和点赞。gif图片太大，进行了压缩，影响效果，由于素材牵扯版权的问题，暂时也不能提交代码，希望能制作素材的朋友联系。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列06：导出excel合并单元格]]></title>
    <url>%2F2020%2F05%2F14%2Fdavinci-dev-xsl%2F</url>
    <content type="text"><![CDATA[前言​ 系统数据导出excel已经很具普遍性，不单单是BI有这需求，表单性质的数据大都希望直接导出excel，这个需求甚至比邮件接收更加突出。 ​ Davinci导出excel有两种方式，都在dashboard页面 单个widget导出 整个dashboard导出，多个sheet页，一个sheet页对应一个widget数据 表格数据 ​ Davinci透视驱动和图表驱动下都有表格的功能，表格中维度指标是自动合并的，效果如下： 图表驱动 透视驱动 表格导出excel​ 这里先不考虑图形效果的数据导出，表格数据更希望导出excel是相同的样式，也就是自动合并单元格，现有的表格数据导出效果如下： 图表驱动 透视驱动 图表驱动表格excel自动合并单元格合并后效果图图表驱动 透视驱动 了解现有逻辑12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 通过代码和依赖可以看出采用的poi处理导出excel 改造计划​ 如果通过现有的方式加入合并单元格的逻辑改造有点麻烦，这里我们直接找较完善的poi合并单元格的方法来直接引用并调用，如果有更好的方式可以一起讨论交流，欢迎留言。 ​ 参考poi合并单元格：https://www.cnblogs.com/mr-wuxiansheng/p/7930378.html 代码改造​ 参考上面链接这里直接提供改造后端的代码 一新增PoiInfo实体类，严格意义上这应该是DO这样我们放的DTO下面 12345678910111213141516171819202122232425262728package edp.davinci.dto.poiDto;import lombok.Data;import java.io.Serializable;/** * POI Excel报表导出，列合并实体&lt;br&gt; */@Datapublic class PoiInfo implements Serializable&#123; private static final long serialVersionUID = 1L; private String content; private String oldContent; private int rowIndex; private int cellIndex; public PoiInfo() &#123; &#125; public PoiInfo(String content, String oldContent, int rowIndex, int cellIndex) &#123; this.content = content; this.oldContent = oldContent; this.rowIndex = rowIndex; this.cellIndex = cellIndex; &#125; @Override public String toString() &#123; return &quot;PoiInfo [content=&quot; + content + &quot;, oldContent=&quot; + oldContent + &quot;, rowIndex=&quot; + rowIndex + &quot;, cellIndex=&quot; + cellIndex + &quot;]&quot;; &#125;&#125; 二废弃writeLine方法，新增createSheet方法 1\server\src\main\java\edp\davinci\service\excel\AbstractSheetWriter.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * @param queryColumns 标题集合 queryColumns的长度应该与list中的model的属性个数一致 * @param maps 内容集合 * @param mergeIndex 合并单元格的列 */ public Boolean createSheet(Sheet sheet,List&lt;QueryColumn&gt; queryColumns, Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; maps, int[] mergeIndex)&#123; if (queryColumns.size()==0)&#123; return false; &#125; int n = 0; for(Map.Entry&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; entry : maps.entrySet())&#123; /*初始化head，填值标题行（第一行）*/ Row row0 = sheet.createRow(0); for(int i = 0; i&lt;queryColumns.size(); i++)&#123; /*创建单元格，指定类型*/ Cell cell_1 = row0.createCell(i, Cell.CELL_TYPE_STRING); cell_1.setCellValue(queryColumns.get(i).getName()); &#125; /*得到当前sheet下的数据集合*/ List&lt;Map&lt;String, Object&gt;&gt; list = entry.getValue(); /*遍历该数据集合*/ List&lt;PoiInfo&gt; poiInfos = new ArrayList(); if(true)&#123; Iterator iterator = list.iterator(); int index = 1; while (iterator.hasNext())&#123; Row row = sheet.createRow(index); /*取得当前这行的map，该map中以key，value的形式存着这一行值*/ Map&lt;String, String&gt; map = (Map&lt;String, String&gt;)iterator.next(); /*循环列数，给当前行塞值*/ for(int i = 0; i&lt;queryColumns.size(); i++)&#123; String old = &quot;&quot;; /*old存的是上一行统一位置的单元的值，第一行是最上一行了，所以从第二行开始记*/ if(index &gt; 1)&#123; old = poiInfos.get(i)==null?&quot;&quot;: poiInfos.get(i).getContent(); &#125; /*循环需要合并的列*/ for(int j = 0; j &lt; mergeIndex.length; j++)&#123; if(index == 1)&#123; /*记录第一行的开始行和开始列*/ PoiInfo poiInfo = new PoiInfo(); poiInfo.setOldContent(String.valueOf(map.get(queryColumns.get(i).getName()))); poiInfo.setContent(String.valueOf(map.get(queryColumns.get(i).getName()))); poiInfo.setRowIndex(1); poiInfo.setCellIndex(i); poiInfos.add(poiInfo); break; &#125;else if(i &gt; 0 &amp;&amp; mergeIndex[j] == i)&#123; /*这边i&gt;0也是因为第一列已经是最前一列了，只能从第二列开始*/ /*当前同一列的内容与上一行同一列不同时，把那以上的合并, 或者在当前元素一样的情况下，前一列的元素并不一样，这种情况也合并*/ /*如果不需要考虑当前行与上一行内容相同，但是它们的前一列内容不一样则不合并的情况，把下面条件中 ||poiModels.get(i).getContent().equals(map.get(title[i])) &amp;&amp; !poiModels.get(i - 1).getOldContent().equals(map.get(title[i-1]))去掉就行*/ if(!poiInfos.get(i).getContent().equals(String.valueOf(map.get(queryColumns.get(i).getName()))) || poiInfos.get(i).getContent().equals(String.valueOf(map.get(queryColumns.get(i).getName()))) &amp;&amp; !poiInfos.get(i - 1).getOldContent().equals(String.valueOf(map.get(queryColumns.get(i-1).getName()))))&#123; /*当前行的当前列与上一行的当前列的内容不一致时，则把当前行以上的合并*/ CellRangeAddress cra=new CellRangeAddress(poiInfos.get(i).getRowIndex(), index - 1, poiInfos.get(i).getCellIndex(), poiInfos.get(i).getCellIndex()); //在sheet里增加合并单元格 sheet.addMergedRegion(cra); /*重新记录该列的内容为当前内容，行标记改为当前行标记，列标记则为当前列*/ poiInfos.get(i).setContent(String.valueOf(map.get(queryColumns.get(i).getName()))); poiInfos.get(i).setRowIndex(index); poiInfos.get(i).setCellIndex(i); &#125; &#125; /*处理第一列的情况*/ if(mergeIndex[j] == i &amp;&amp; i == 0 &amp;&amp; !poiInfos.get(i).getContent().equals(String.valueOf(map.get(queryColumns.get(i).getName()))))&#123; /*当前行的当前列与上一行的当前列的内容不一致时，则把当前行以上的合并*/ CellRangeAddress cra=new CellRangeAddress(poiInfos.get(i).getRowIndex(), index - 1, poiInfos.get(i).getCellIndex(), poiInfos.get(i).getCellIndex()); //在sheet里增加合并单元格 sheet.addMergedRegion(cra); /*重新记录该列的内容为当前内容，行标记改为当前行标记*/ poiInfos.get(i).setContent(String.valueOf(map.get(queryColumns.get(i).getName()))); poiInfos.get(i).setRowIndex(index); poiInfos.get(i).setCellIndex(i); &#125; /*最后一行没有后续的行与之比较，所有当到最后一行时则直接合并对应列的相同内容*/ if(mergeIndex[j] == i &amp;&amp; index == list.size())&#123; CellRangeAddress cra=new CellRangeAddress(poiInfos.get(i).getRowIndex(), index, poiInfos.get(i).getCellIndex(), poiInfos.get(i).getCellIndex()); //在sheet里增加合并单元格 sheet.addMergedRegion(cra); &#125; &#125; Cell cell = row.createCell(i, Cell.CELL_TYPE_STRING); cell.setCellValue(String.valueOf(map.get(queryColumns.get(i).getName()))); /*在每一个单元格处理完成后，把这个单元格内容设置为old内容*/ poiInfos.get(i).setOldContent(old); &#125; index++; &#125; &#125; n++; &#125; return true; &#125; 三放弃原来template.query 使用lambda表达式的调用方式（注释部分），修改如下 1\server\src\main\java\edp\davinci\service\excel\SheetWorker.java 123456789101112131415161718192021222324252627// template.query(sql, rs -&gt; &#123;// Map&lt;String, Object&gt; dataMap = Maps.newHashMap();// for (int i = 1; i &lt;= rs.getMetaData().getColumnCount(); i++) &#123;// dataMap.put(SqlUtils.getColumnLabel(queryFromsAndJoins, rs.getMetaData().getColumnLabel(i)), rs.getObject(rs.getMetaData().getColumnLabel(i)));// &#125;// writeLine(context, dataMap);// count.incrementAndGet();// &#125;); List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); // 获取合并列 List&lt;Integer&gt; listIt = new ArrayList&lt;Integer&gt;(); for (int j = 0; j &lt; context.getQueryColumns().size(); j++) &#123; QueryColumn queryColumn = context.getQueryColumns().get(j); if(!queryColumn.getType().equals(&quot;value&quot;))&#123; listIt.add(j); &#125; &#125; int[] mergeIndex = new int[listIt.size()]; int i = 0; for(Integer it: listIt)&#123; mergeIndex[i++] = it.intValue(); &#125; Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; map = new HashMap(); map.put(&quot;合并单元格数据&quot;, list); createSheet(context.getSheet(),context.getQueryColumns(),map,mergeIndex); 完成以上配置，效果就有了 存在问题透视驱动表头样式​ 目前无法做到透视驱动的表头样式，数据导出excel也仅仅和图表驱动类似的单元格数据的合并。 表头样式进行分组合并影响导出​ 表头样式进行分组合并设置，会影响导出，后续再进行处理。 图表驱动表格合并存在不合理情形数据第一层维度数据不同，第二次数据相同合并，似乎不合理，excel做了处理，这样就不一致，如下情况： 交流学习学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列12：0.35版本表达式是真的香]]></title>
    <url>%2F2020%2F04%2F12%2Fmetabase-bi-v035%2F</url>
    <content type="text"><![CDATA[​ 2020年3月30日，Metabase0.35版本真的来了，正如官方所说，0.35真的是一个重要的版本，最重磅的升级就是自定义表达式的升级，直接使Metabase的查询编辑器有了质的飞跃，对数据分析中自定义列、数据过滤器、数据聚合功能有了很大的提升。 ​ 这个重要的升级通俗讲： 提升数据处理能力，不用写sql就能进行更多的数据转换 不同数据库，通用处理规则，提升用户体验 改为用[]方式获取字段，自动提示操作十分人性化 升级前后对比 序号 功能 升级前 升级后（0.35之后） 1 自定义列 只支持数字类型的+，-，*，/ 1、支持字符字段2、新增字符和数字处理18个函数abs，concat等3、支持升级前功能 2 过滤器 1、单个字段判断筛选2、数字类型是，不是，为空，不为空3、字符类型除上面四个外，还有包含，不包含，以..开始，以..结束4、其它类型不再赘述，升级前后未变化 1、支持自定义表达式2、新增函数支持between，contains，ednWith，startWith，interval3、扩展运算符：AND，OR，NOT，&gt;，&gt;=，&lt;，&lt;=，=，!=4、支持升级前功能 3 聚合 1、支持自定义表达式2、原有聚合函数的+，-，*，/ 1、支持自定义表达式2、新增了9中数字的处理函数3、支持升级前功能 过滤器： 聚合： 新增表达式介绍这次表达式确实扩展了很多，这里挑了几个常用的预览一下，也可以去Metabase官方查看全部表达式 名称 句法 备注 例 Between between(column, start, end) 1、日期范围内 2、数字区间内 between( [Rating], 3.75, 5 ) Case case(condition, output, condition, output …) 多情况判断，如枚举类型 case( [Weight] &gt; 200, “Large”, [Weight] &gt; 150, “Medium”, “Small” ) 返回非空值 coalesce( value1, value2, …) 按顺序查看每个参数中的值，并为每行返回第一个非空值。 coalesce( [Comments], [Notes], “No comments” ） 字符串拼接 concat(value1, value2, …) 1、字符串或字段拼接 2、数值会转换字符拼接（已测试） concat([Last Name] , “, “, [First Name]) 长度 length(text) 返回文本中的字符数 length([Comment]) 小写转换 lower(text) 以小写形式返回文本字符串。 lower( [Status] ) 去除左空格 ltrim(text) ltrim( [Comment] ) 正则表达式提取 regexextract(text, regular_expression) 根据正则表达式提取匹配的子字符串 regexextract( [Address], “[0-9]+” ) 替换 replace(text, position, length, new_text) replace( [Order ID], 8, 3, [Updated Part of ID] ) 去除右空格 rtrim(text) rtrim( [Comment] ) 截取字符串 substring(text, position, length) substring( [Title], 0, 10 ) 去除空格 trim(string) trim( [Comment] ) 大写转换 upper(text) upper( [Status] ) 也可直接查看更多表达式连接（谷歌自动翻译）：https://ossbao.oss-cn-qingdao.aliyuncs.com/blog/Metabase/12/Metabase-bds.html 0.35其它说明 新增表达式并不能兼容所有的数据库，因为数据库差异很大，做到这种程度已经很牛x了，表达式数据库兼容情况参加官方说明 此外0.35版本调整了查询结果缓存内存的策略，改为数据库流，调整了一些api，着眼性能提升 当然少不了的就是修复bug了，参加官方说明 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列05：echarts-gl map3D扩展]]></title>
    <url>%2F2020%2F04%2F03%2Fdavinci-dev-egl%2F</url>
    <content type="text"><![CDATA[echarts-gl​ 介绍一下echarts-gl，charts-gl专门为echarts补充了丰富三维可视化组件。这里的gl应该是global的意思，很多地方简写GL，不建议这样写，因为和真实的GL太冲突，更何况最近肖某的事情，和BL有着千丝万缕的关系，所以，就别和GL扯上关系，我们还是写全称echarts-gl。 echarts-gl map3D​ 这次介绍echarts-gl map3D，就是用echarts-gl实现的地图的3D模式，也是在系列03的基础上进行的改造，开启3D，切换地图，效果如下： echarts-gl安装1cnpm install echarts-gl --save 页面引入1import &apos;echarts/dist/echarts-gl&apos; 特别注意一下：如果集成了百度地图，这个引入不要放入到app.tsx里面，会出现一直加载不完的情况，所以最好放到chart.tsx 控制参数​ 在样式里面，添加控制参数，开启3D render调整​ 在render下面的map.ts调整图形，主要是series的属性 12map：&apos;&apos; // 注意与echarts.registerMap第一个参数保持一致type: &apos;map3D&apos; // 通过type指定必须是map3D，还有一种方式geo3D，见echarts官方实例 完成以上配置，效果就有了 echarts-gl事件存在问题​ echarts-gl图表事件一直存在问题，算是个坑，截止目前，我统计了一下官方issue关于事件目前一直open的最少四个，echarts-gl目前维护进度也较慢。 ​ 试了几个版本的echarts-gl，发现对于不同的版本： 有版本需要加getZr()，有的版本不需要 有的事件需要加getZr()，有的事件不需要 有的版本获取不到区域名称，只能获取到坐标，有的版本能 有的版本区域域名加了getZr()能获取到，有的不加能获取到，有的都能，有的都不能 ​ 我目前使用的版本1.1.1，单击事件不用加getZr()，右键事件需要加，但是右键事件获取不到区域名称，如果发现某个版本单击和右键事件都有，并能获取到取到区域名称，烦请留言告知，在此谢过。 ​ 就拿我们用的单击和右键事件来说： ​ 单击事件实现方式： 12345678// 方式一myChart.on(&apos;click&apos;, function (params) &#123; console.log(params);&#125;);// 方式二myChart.getZr().on(&apos;click&apos;, function (params) &#123; console.log(params);&#125;); ​ 右键事件 12345678// 方式一myChart.on(&apos;contextmenu&apos;, function (params) &#123; console.log(params);&#125;);// 方式二myChart.getZr().on(&apos;contextmenu&apos;, function (params) &#123; console.log(params);&#125;); 几个推荐和注意echarts-gl地图下钻​ 如果echarts-gl 地图下钻，一些类似边框、颜色等属性，需要在下钻事件里面重新调整，否则下钻到新的地图属性不能匹配。 echarts-gl map3D组合图形​ 如果仅仅echarts-gl map3D效果没那么出众，一般都是配合其它图形，在地图上放柱形、雨滴等会更突出3D效果，所以可以进一步扩展。 echarts-gl性能​ 这里map3D较简单，性能未发现问题，echarts-gl有很多空间性很强的图形，这种图形渲染加载都会比2D慢，所以性能也是需要考虑的，其它3D图形用的维度指标较多，性能有待测试验证。 geo3D和map3d区别geo3D不支持visualMap，显示3D地理，上面可以加柱状图，各省份数据无法展示。 map3d支持visualMap，可以显示区域数据，不能绘制柱状图，但是也有说可以隐藏一个geo3D来实现，所以待验证，大家可以尝试一下。 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列04：自定义水印扩展]]></title>
    <url>%2F2020%2F04%2F03%2Fdavinci-dev-water%2F</url>
    <content type="text"><![CDATA[水印（watermark）​ 目前来看，水印已经具有很高的附加价值了，钱币的水印能防伪，资料上的水印能宣传，甚至很多对外的产品软件都把去水印当成VIP的一项特殊功能，随着知识产权加强，知识付费的流行，水印也成了防止盗用的一种很重要的手段。 ​ Davinci的水印我觉着官方迟早会出，但目前来看短时间出不来，出成什么样子也不确定，所以我们就先制瓜吃瓜。 ​ 效果： 水印制作自定义水印位置​ 既然是自定义水印，自然也离不开用户和权限，为了先实现自定义，不考虑复杂因素，自定义水印根据项目划分，支持快捷显示项目名称等，不考虑用户自定义和项目自定义水印同时存在的情况。 ​ 在用户界面》》组织》》项目》》设置》》水印设置 水印显示位置目前来看有这么几个位置： widget编辑区（编辑区理论不需要水印，观点不一） dashboard看板 display大屏 widget分享面板（官方留了口子，但没有实现完善，暂不考虑） dashboard分享面板 display分享面板 widget工作区： dashboard页面： display页面： 水印属性 开启关闭 项目名称 用户名 水印文本（比如“内部资料，严禁外传”这类） 水印时间戳（支持多种日期格式） 水印颜色 备注：未实现上传图片等格式的水印 水印编码实现用户信息获取​ 登录用户信息获取目前有两种 ​ 方式一： 123const mapStateToProps = createStructuredSelector(&#123; loginUser: makeSelectLoginUser(),&#125;) ​ 方式二： 1const loginUser = localStorage.getItem(&apos;loginUser&apos;) 项目信息获取123const mapStateToProps = createStructuredSelector(&#123; currentProject: makeSelectCurrentProject()&#125;) 后台改造后台改造比较简单： 第一：project表增加config字段，类型text，注意和json的转换 第二：分享功能增加project信息，用于展示项目名称，因为分享不登录状态即可访问，所以无法显示用户名 前端改造前端改造难点除代码语法外， 第一：重点还是在用户名称和项目名称获取上 第二：自定义水印在组织里面，项目的获取和值传递 第三：分享功能，项目信息传递 第四：水印组件引入可以放在多个位置，放到widget下面会比较省劲，尤其是要求多个地方都呈现水印 几个推荐和注意dashboard和display水印问题​ 第一：看上面的效果图能明显看到水印是最终实在单个widget下面的，而不是在整个面板上的，整体效果就差一些 ​ 第二：尤其是大屏这种，可以考虑每个大屏自定义水印，因为大屏有自身特有的组件 导出excel水印数据导出excel同样需要水印，推荐实现 分享链接的水印Davinci里面widget、dashboard、display都支持分享，widget不完善，分享不受权限控制，也不是我们正常进入到某个项目里面的操作，而我们的自定义水印是根据项目设定的，所以分享链接需要根据dashboard获取项目信息和水印的配置信息，并传递到widget组件里。 定时任务邮件接收水印邮件接收报表带水印是非常合理的，根据水印时间戳更是能够准确判断当前报表的出具时间。 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列03：区域地图下钻与选择]]></title>
    <url>%2F2020%2F03%2F28%2Fdavinci-dev-map%2F</url>
    <content type="text"><![CDATA[概述系列02中讲到百度地图扩展，地图应用场景多样，对于BI数据的呈现区域地图（非经纬度坐标）似乎应用更加广泛，这次说一下对于区域地图的几点改造。一个是下钻，一个是指定自定义的区域地图。 地图下钻层级下钻，没有具体的几级，可以一直下钻并返回，这里做了国家、省份、市、区县、街道的下钻。 指定地图指定需要展示的地图，并可以钻取和上卷。 吐槽一下Davinci地图Davinci 地图目前十分的不友好，不得不吐槽一下： 不能很好的扩展地图 地图数据逻辑，通过地理类型和对照js文件去汇总，这种十分的不灵活 地图真实应用需求类似下钻不能满足 地图改造点去掉原有的地图类型​ 原有地图类型：地图、气泡图、热力图、飞行图， ​ 改造后：去掉地图类型 ​ 这些需求在区域地图上是有的，官方就是考虑这些类型的实现导致区域地图显得复杂，尤其是飞行图这种实际BI应用场景中较少，而且飞行图是要有起点的，默认指定的第一个为起始点，非配置化，略显鸡肋。我们已经在百度地图扩展里做了一些实现，这里直接去掉原有的地图类型，简化代码，更突出区域地图的功能。 数据类型扩展​ 原类型：地理国家、地理省份、地理城市 ​ 扩展后：增加地理区县和地理街道 ​ 备注：实际改造了数据组装逻辑之后，类型仅仅是体现特殊性的地理维度，并不是严格的层级区分了，就是说改造之后实际指定的类型不影响数据展示。 数据组装逻辑改造​ 原逻辑：根据配置的地理类型，根据层级对照的js文件进行汇总计算。 ​ 改造后：根据实际数据进行自动汇总处理，与类型无关，即相同字段名称的汇总。 增加单击下钻右键返回事件​ 添加单击和右键事件实现下钻返回。 12345678instance.off(&apos;click&apos;)instance.on(&apos;click&apos;, (params) =&gt; &#123; // 添加单击事件&#125;)instance.on(&apos;contextmenu&apos;, (params) =&gt; &#123; // 添加右键事件&#125;) 地图json文件扩展​ 既然能够指定区域地图，就要有地图的json文件，这里推荐两个免费的json地图地址。 ​ 阿里的：http://datav.aliyun.com/tools/atlas/#&amp;lat=33.54139466898275&amp;lng=104.2822265625&amp;zoom=4 ​ 个人的：https://gallery.echartsjs.com/editor.html?c=xr1IEt3r4Q 更新很及时，行政区划调整比较及时。 ​ 中国闭源软件多，开源软件少，可能一个原因是付费的少，这些作者提供的json文件着实给力，所以建议大家使用之余，能力范围内打赏一下（非广告）。 几个推荐和注意json文件改造自定义上传​ 可以改造json文件自定义上传，这样用户可以自己上传json文件然后从地图样式里面指定。 json层级建立对照字典表​ 对于自定义上传的json文件建立层级对照表，源码里面通过js文件对照的，不利于维护。 普通图表下钻功能的影响​ Davinci dashboard有下钻的功能，并且图表的钻添加了右键事件，所以需要进一步验证是否存在冲突的问题。 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列11：看板模式扩展及使用]]></title>
    <url>%2F2020%2F03%2F24%2Fmetabase-bi-theme%2F</url>
    <content type="text"><![CDATA[两种模式​ 最近微信的暗黑模式似乎比较火，为大家熬夜又增添一些乐趣，这次说一下Metabase里面的扩展新的模式，熟悉Metabase的人都知道，Metabase的看板dashboard有两种模式：白天模式、夜间模式 白天模式： 夜间模式： 由于Metabase BI开源版本只支持白天、夜晚两种模式，现改造可进行定制开发，并支持切换多模式。 Metabase BI主题是采用前端参数配置，未将主题设置保存数据库，保留原有设计，通过参数控制主题显示。 后期根据用户需求进行定制改造即可 如何扩展模式呢新增模式修改文件 /metabase/frontend/src/metabase/components/icons/NightModeIcon.jsx 123456const OPTIONS = [ &#123; name: t`白天模式`, theme: &quot;sun&quot; &#125;, &#123; name: t`夜间模式`, theme: &quot;moon&quot; &#125;, &#123; name: t`蓝色模式`, theme: &quot;blue&quot; &#125;, &#123; name: t`主题名称`, theme: &quot;主题标识&quot; &#125;,]; 模式图标定制Metabase主推图标icon采用的svg path方式，修改文件/metabase/frontend/src/metabase/icon_paths.js 例如： 1234moon: &quot;M11.6291702,1.84239429e-11 C19.1234093,1.22958025 24.8413559,7.73631246 24.8413559,15.5785426 C24.8413559,24.2977683 17.7730269,31.3660972 9.05380131,31.3660972 C7.28632096,31.3660972 5.58667863,31.0756481 4,30.5398754 C11.5007933,28.2096945 16.9475786,21.2145715 16.9475786,12.9472835 C16.9475786,7.90001143 14.9174312,3.32690564 11.6291702,1.70246039e-11 L11.6291702,1.84239429e-11 Z&quot;,新增主题标识: &quot;M16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 30c-1.967 0-3.84-0.407-5.538-1.139l7.286-8.197c0.163-0.183 0.253-0.419 0.253-0.664v-3c0-0.552-0.448-1-1-1-3.531 0-7.256-3.671-7.293-3.707-0.188-0.188-0.442-0.293-0.707-0.293h-4c-0.552 0-1 0.448-1 1v6c0 0.379 0.2144.208z&quot;, 模式样式修改修改文件/metabase/frontend/src/metabase/css/dashboard.css 样式涉及dashboard背景、标题，card图例、标题、背景等样式，所以将各样式设置Dashboard–+主题标识的方式 123456789101112131415161718192021222324252627282930/* moon mode start*/.Dashboard.Dashboard--主题标识&#123; background-color: var(--color-bg-black);&#125;.Dashboard.Dashboard--主题标识 .DashboardHeader &#123; color: var(--color-text-white);&#125;.Dashboard.Dashboard--主题标识 .Card &#123; color: var(--color-text-white);&#125;.Dashboard.Dashboard--主题标识 .Header-button,.Dashboard.Dashboard--主题标识 .Header-button svg &#123; color: color(var(--color-text-medium) alpha(-70%));&#125;.Dashboard.Dashboard--主题标识.Dashboard--fullscreen .fullscreen-night-text &#123; color: color(var(--color-text-white) alpha(-14%)); transition: color 1s linear;&#125;.Dashboard.Dashboard--主题标识 .DashCard .Card svg text &#123; fill: color(var(--color-text-white) alpha(-14%)) !important;&#125;.Dashboard.Dashboard--主题标识 .DashCard .Card &#123; background-color: var(--night-mode-card); border-color: var(--night-mode-card);&#125;.Dashboard.Dashboard--主题标识 .enable-dots-onhover .dc-tooltip circle.dot:hover,.Dashboard.Dashboard--主题标识 .enable-dots .dc-tooltip circle.dot &#123; fill: currentColor;&#125;/* moom mode end*/ 模式使用模式切换重新打包发布应用，重启应用程序，web端进入dashboard编辑或者预览的全屏模式先，点击切换模式即可 原模式切换： 改造后模式切换： 参数配置化url+#theme=模式标识 如：http://localhost:3000/dashboard/10#theme=blue 注意点源码中模式切换是Boolean类型，如果改成多模式，就不止两种类型，所有需要改成String类型 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列02：widget百度地图扩展]]></title>
    <url>%2F2020%2F03%2F19%2Fdavinci-dev-bmap%2F</url>
    <content type="text"><![CDATA[概述Davinci 目前的地图是区域地图，取自json文件，地图目前是写死状态，区域地图下还有气泡图、飞行图和热力图，存在bug且这种写死的状态实在很难满足真实需求。 Davinci 目前没有集成百度或者高德地图，下面就说一下扩展百度地图的思路，其实也适用于echarts下的图表扩展，只不过地图有点特殊，由于echarts官网有百度地图的demo，所以选择百度地图，扩展起来应该更容易，高德地图也是可以的。 widget介绍Davinci 设计理念里面指出，Davinci 围绕 View（数据视图）与 Widget（可视化组件）两个核心概念设计，其中Widget就是我们说的饼图、柱状图、表格、折线图等等组件，其实对于BI软件来说，数据的图表呈现是很重要的一部分，而且Widget工作台也是Davinci里面最复杂的一块。 Davinci workbench工作台如图： workbenchDavinci workbench工作台是很核心的且复杂的一部分，对于echart图表的扩展，主要对其修改即可。 透视驱动和图表驱动透视驱动：以透视表为基础的可视化展示逻辑，可以简单认为复杂度比较高的，但是也强调了目前透视驱动的配置项完善度不如图表驱动，关于透视表可以看一下之前写的关于透视表PR那篇blog。 图表驱动：图表驱动即为常规的、基于图表分类的可视化展示逻辑。 workbench前端代码目录123456789101112131415161718192021└── webapp └── app └── containers └── Widget //widget功能所在文件夹 ├── component //组件 | ├── Chart（图表驱动） | ├── Config | ├── Pivot（透视驱动） | ├── Widget | └── Workbench //工作台显示区（图表、数据、样式、配置） | | ├── ConfigSections //各个图表样式（图例、颜色、标签、xy轴等）配置 | | | ├── SpecSection | | | └── TableSection | | └── Dropbox ├── config //初始化配置信息（数据、样式、配置） | ├── chart（图表驱动） | └── pivot（透视驱动） ├── render //根据信息最后处理（拼装echarts需要的配置） | ├── chart（图表驱动） | └── pivot（透视驱动） ... echarts组件扩展概括起来就三个步骤 扩展图表驱动图标 扩展图表样式（也可以用原有的，一般每个图表都有自己特有的一些样式配置） 可以参见webapp/app/containers/Widget/component/Workbench/ConfigSections/SpecSection/specs下的任意一个 扩展图表echarts拼装 可以参见webapp/app/containers/Widget/render/chart下的任意一个 百度地图扩展效果气泡根据数据变化大小和颜色 气泡根据数据变化颜色，大小不变 气泡水波效果 绿色雨滴效果 黑色热力效果 几个推荐和注意百度地图秘钥需要去百度地图开放平台申请秘钥，并引入百度地图插件 放到app下面index.html里即可 1&lt;script src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=秘钥&quot;&gt;&lt;/script&gt; react引入echarts百度地图扩展可以放到app.tsx里面，也可以放到widget组件chart.tsx里面（推荐） 1import &apos;echarts/extension/bmap/bmap&apos; 图标使用阿里的iconfontDavinci 使用的就是阿里的iconfont，所以这了也建议使用，存放在assets/font下面，像ttf和woff文件需要找专门的工具做导入，比较多容易搜到。 echarts地图和其它图表切换问题比如饼图切换柱状图，直接clear就行，但是百度地图不能直接clear所以需要dispose以下然后再创建，目前没有找到更好的办法。 数据和echarts组装参见官网空气质量-百度地图地址：https://www.echartsjs.com/examples/zh/editor.html?c=effectScatter-bmap 地图主题使用地图编辑器官方编辑器，个性化地图：http://lbsyun.baidu.com/apiconsole/custommap 如果想要现成的推荐使用，百度地图个性在线编辑器：https://developer.baidu.com/map/custom/ 可以自动生成配置的json文件，强烈推荐！！！ 中心坐标和缩放比例目前中心坐标和缩放比例手动输入，不能从百度地图自动获取 气泡大小随数值大小变化问题数据量级跨度较大的数据，不能很好的展示气泡大小显示效果，可以用最大最小值做一些简单的处理，期待有更好的算法规则。 经纬度设置问题百度地图需要经纬度定位，图表维度里面需要拖入经纬度，并且需要提前设置维度类型为经纬度才可以。 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Davinci-二次开发系列01：开篇]]></title>
    <url>%2F2020%2F03%2F19%2Fdavinci-dev-kp%2F</url>
    <content type="text"><![CDATA[概述Davinci 是宜信出品的DVaaS（数据可视化及服务）的一款BI产品，翻译过来是达芬奇，达芬奇大家都知道著名画家，代表作有《蒙娜丽莎》。所以通过名字就能看出来宜信对着产品的厚望，颇有一种想要成为大师的意思。 百度搜Davinci会搜出DaVinci Resolve这款不知道你知不知道的调色软件，所以看来宜信这名字没起好，导致宜信Davinci目前来看已经藏着了百度第二页。 宜信公司：成立于2006年，专注围绕普惠金融和财富管理。 宜信技术学院：宜信技术团队，2017年，宜信技术学院正式成立，通过分享在金融科技领域的开源成果、研发实践促进金融科技生态圈企业创新升级，确实很牛的样子。 宜信开源主要的开源产品可以在宜信技术学院官网上找到：http://college.creditease.cn/techOpenSource DBus：专注于数据的收集及实时数据流计算 Moonbox：是一个DAAS（Data Virtualization as a Service）平台解决方案 Wormhole：是一个SPAAS（Stream Processing as a Service）平台解决方案 Davinci：是一个DVAAS（Data Visualization as a Service）平台解决方案 宜信技术学院号称利用开源来支撑智能化运维 技术框架Davinci 采用前端分离的方式，后端java系，前端react，图表echarts。 前端：Antd + ES6 + TypeScript + WebPack Antd：Ant Design of React，基于 Ant Design 设计体系的 React UI 组件库，是蚂蚁金服一套开箱即用的高质量 React 组件，Davici 用Reac 实现，此外Ant Design 还有 Angular、Vue 的实现 ES6：新一代js语法，过！ TypeScript：一种由微软开发的开源、跨平台的编程语言，JavaScript的超集，最终会被编译为JavaScript代码 WebPack：打包工具，过！ 后端：springboot + mybatis-plus + maven 后端java，标准的springboot、mybatis-plus框架，容易理解。 此外采用swagger框架生成api接口说明。 图表库：echart，特点就是使用和集成简单，但是没有D3那么灵活。 二次开发Davinci 源代码github地址：https://github.com/edp963/davinci 二次开发完全可以参考Davinci 的使用手册的文档说明，介绍比较详细，这里只说几个注意点。 注意点一：分支这里需要注意一下，目前Davinci默认的分支是dev-0.3，目前Davinci最新维护的版本是0.3版本，所以clone最新dev-0.3版本即可。 注意点二：前端installDavinci 前端启动install的时候，建议使用cnpm install，不要用npm install即使设置使用淘宝源也容易出现问题。 注意点三：前端启动错误前端启动会发现有很多文件报错，有些可能是严格校验导致的，大部分确实存在严格意义上的错误，但是不用管这些错误就可以了，不影响使用和二次开发。 注意点四：前端发布Davinci 前端发布访问的是davinci-ui文件夹下面，前端打包在webapp的build下面，所以如果正式发布，需要将build下的文件拷贝到davinci-ui下面，bin下面未提供自动前端发布的脚本命令，此外由于每次打包生成的前端文件命名不一样，davinci-ui下的原文件删除即可。 注意点五：邮件定时任务除了邮件的邮箱配置正确以外，如果想正常接收，需要安装phantomjs。 点评一下Davinci概览里面已经把架构、设计理念、功能特点等等介绍的挺全面的了，这里在突出强调几个点： 数据行列权限控制的比较全 大屏display功能亮点，大屏数据可视化展示已然成为未来的趋势，目前不完善，提升改造空间大 功能确实很全，透视表功能也比较完善 针对二次开发的优缺点： java系并采用主流框架易于二次开发 架构清晰，易于理解 开源时间短，社区论坛没有，资料相对较少 功能多，bug也多 代码质量略差，有明显多人开发和功能需求增加引起的规范性上的不完美 前端界面尤其移动端效果较差，这个同样也给二次开发带来更大的提升空间 不管怎么说，Davinci还是挺不错的一块BI产品，也比较适合二次开发。 交流学习刚建的群，学习Metabase、Davinci等开源BI，群号：72569367，感兴趣的可以加一下。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Davinci</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Davinci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列10：新版透视表实现方案]]></title>
    <url>%2F2020%2F02%2F27%2Fmetabase-bi-tabfa%2F</url>
    <content type="text"><![CDATA[​ 之前已经介绍了复杂表头表格的开源PR，时间较早，基于Metabase V0.30版本的实现，而Metabase V0.33版本之后变化较大，所以如果在新版上实现PR中Metabase 复杂表头表格功能需要做改造。当然如果实力允许，你也可以按照自己的思路去实现。 ​ 详情可以到github上看一下,PR：Metabase pull request #8427 ​ 效果如下： ​ 实现​ 准备工作：到r-hot下面找到fork下来的Metabase下面，找到summaryTable这个分支，clone一份。 ​ 由于Metabase 架构完善，高度组件化，所以不用担心对代码的影响，耦合性相对很低。 ​ 作者就是新加了一种可视化图表的类型： ​ ​ 所以，可以顺着这个新增的可视化组件，找到需要的文件，透视表所用到的组件大部分以summary开头或者包含summary，这里就不一一列出了，然后放到最新版的Metabase源码对应目录下面，然后编译启动就可以了。 ​ 注意：Metabase透视表功能用到了一些开源的npm组件，需要引入，也可以看我上一篇文章实现解析里面提到的内容 ​ 但是由于Metabase新旧版本返回的数据结构有所变化所以需要处理之后才能实现正常的功能，所以给出了下面的两种解决方案： 方案一​ Metabase为什么把columns去掉不得知，也不像是因为用不到就就去掉的，起码在我看来保留这么一个设计还是很方便的，透视表PR就充分利用了这一点。新版的虽然说是去掉了，但是也不是完全去掉，只是屏蔽掉了。所以方案一就是把columns放出来就可以了，透视表的功能就能正常使用。 找到代码目录/src/metabase/query_processor/middleware/dev.clj中的代码 123;; 放开columns权限，将columns换个名字就可以了，这里我加了AA(complement :columnsAA)&quot;QP results should no longer include :columns.&quot;)) 方案二​ 如果考虑官方既然已经屏蔽了，考虑以后代码更新，你不想放开colums，那就需要在透视表用的代码里面对columns进行处理，其中一种方式就是cols里面获取，当然你也可以用其他方式处理甚至是替换columns处理的方式，推荐一种处理方式如下： 123456 columns = [] if(cols.length&gt;0)&#123;​ cols.map(item=&gt;&#123;​ columns.push(item.name)​ &#125;) &#125; 备注：里面用到columns的地方挺多，需要处理的地方挺多，目前不确定会不会带来其它问题，但是就目前来看这种处理方式效率会低，本来这种js实现的透视表效率就是一直讨论的问题，所以我建议还是采用方案一的方式效果更好。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列09：透视表PR功能实现解析]]></title>
    <url>%2F2020%2F02%2F27%2Fmetabase-bi-tabjx%2F</url>
    <content type="text"><![CDATA[​ 上一篇文章介绍了Metabase透视表的开源PR，时间较早，基于Metabase V0.30版本的实现，而Metabase V0.33版本之后变化较大，所以如果在新版上实现PR中Metabase 复杂表头表格功能需要做改造。当然如果实力允许，你也可以按照自己的思路去实现。 效果呈现 实现原理数据结构Metabase返回的数据结构，通过前端进行封装，版本之间会存在差别 1frontend\src\metabase\meta\types\Dataset.js 12345678export type DatasetData = &#123; cols: Column[],//列信息 columns: ColumnName[],//备注：新版本没有columns字段 rows: Row[],//行信息 rows_truncated?: number, requested_timezone?: string, results_timezone?: string,&#125;; 新增的图表类型由于Metabase组件化的代码，所以作者新增图表类型，不影响原来的功能和代码 1frontend\src\metabase\visualizations\index.js 123import SummaryTable from &quot;./visualizations/SummaryTable&quot;;registerVisualization(SummaryTable); 复杂表头图表设置项1234567const emptyStateSerialized: SummaryTableSettings = &#123; groupsSources: [], columnsSource: [], valuesSources: [], unusedColumns: [], columnNameToMetadata: &#123;&#125;,&#125;; 行显示字段：多个分组嵌套 列显示字段：列字段只能有一个不支持多个进行嵌套 聚合字段（度量） 不可见字段：分组列表里面有，但是手动设置不显示的字段 行和列字段支持功能： 汇总 排序 核心处理在原有的table基础上进行的修改，主要添加了这个js实现计算汇总及后续处理 1frontend\src\metabase\visualizations\lib\summary_table_datasetdata_builder.js 123456789101112131415161718192021222324252627282930313233343536373839export const buildDatasetData = (//格式化数据集 settings: SummaryTableSettings, mainResults: DatasetData, resultsProvider: ResultProvider,): SummaryTableDatasetData =&gt; &#123; const &#123; columnsHeaders, cols, dimensions &#125; = buildColumnHeaders(//生成列标题 settings, mainResults, ); const compressedColumnsHeaders = tryCompressColumnsHeaders(//压缩列标题处理 settings, columnsHeaders, ); const rowAssembler = getRowAssembler(columnsHeaders);//行数据装配 const queryPlan = getQueryPlan(//生成合计 settings, canTotalizeBuilder(mainResults.cols), ); const rows = combineData(rowAssembler, queryPlan, settings, resultsProvider);//合并数据 //生成列索引 const columnIndexToFirstInGroupIndexes = buildColumnIndexToFirstInGroupIndexes( rows, settings, ); //生成行索引 const rowIndexesToColSpans = buildRowIndexesToColSpans(settings, rows, cols); return &#123; columnsHeaders: compressedColumnsHeaders, cols, columns: cols.map(p =&gt; p.name), rows, columnIndexToFirstInGroupIndexes, isGrouped: columnIndex =&gt; columnIndex in columnIndexToFirstInGroupIndexes, rowIndexesToColSpans, dimensions, &#125;;&#125;; js组件（lodash）数据处理Lodash是一个著名的javascript原生库，不需要引入其他第三方依赖，像Jquery的一样，十分简洁，正是利用lodash实现数据的js处理。 1234567891011121314&quot;lodash.flatmap&quot;: &quot;^4.5.0&quot;,&quot;lodash.get&quot;: &quot;^4.1.2&quot;,&quot;lodash.invert&quot;: &quot;^4.3.0&quot;,&quot;lodash.isequal&quot;: &quot;^4.5.0&quot;,&quot;lodash.mapkeys&quot;: &quot;^4.6.0&quot;,&quot;lodash.mapvalues&quot;: &quot;^4.6.0&quot;,&quot;lodash.orderby&quot;: &quot;^4.6.0&quot;,&quot;lodash.partition&quot;: &quot;^4.6.0&quot;,&quot;lodash.range&quot;: &quot;^3.2.0&quot;,&quot;lodash.set&quot;: &quot;^4.1.2&quot;,&quot;lodash.sortby&quot;: &quot;^4.6.0&quot;,&quot;lodash.unset&quot;: &quot;^4.1.2&quot;,&quot;lodash.values&quot;: &quot;^4.3.0&quot;,&quot;lodash.zip&quot;: &quot;^4.2.0&quot;]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列08：一个关于透视表的PR]]></title>
    <url>%2F2020%2F02%2F27%2Fmetabase-bi-tabpr%2F</url>
    <content type="text"><![CDATA[概述​ Excel中经常用到合并单元格，制作复杂表头的表格（透视表）。后台系统、财务系统、报表系统等等对于这种复杂表头的表格还是很刚需的，尤其是像财务这种系统。Excel很擅长这种复杂表头，实现起来很容易，但是软件系统确并那么容易，复杂度越高难度越大，甚至好多系统研究怎么和Excel做集成，一是Excel的强大，二是最终还是要导出Excel的。 透视表和交叉表区别​ 关于透视表和交叉表的区别，你能搜多一些材料，但是不见的能理解。我个人感觉严格的界限也没那么清晰，只要只知道交叉表专指两列（或者多列）分组出现的频率就可以了，更何况交叉表还是一种特殊的透视表呢。概括起来就这么三点 透视表是一种常见的数据汇总工具，进行数据聚合 交叉表是专指分组频率的 交叉表是一种特殊的透视表 Metabase透视表​ Metabase小清晰、简洁干练的风格似乎对这种复杂的东西似乎格格不入，尽管Metabase有透视表的功能，但Metabase的透视表真的是简单而且别具一格，基本算不上透视表的功能。正因为不满足，总有人蠢蠢欲动，今天就讲一篇Metabase开源库中很多人热衷的一个PR,，关于Metabase透视表的实现。 ​ 效果图如下： 介绍这个PRPR：Metabase pull request #8427 2018年8月30日提出，2020年1月31日由于时间问题和性能问题关闭。 这个复杂表头的表格需求肯定是有的，r-hot进行了尝试，将查询字段按顺序进行分组，并能对分组进行排序，还能显示分组统计。 有184次提交记录 Metabase 源码维护者进行讨论过，查询较多，导致后端沉重，复杂计算存在问题，并提交高级别讨论 此复杂表头的表格，支持sql查询方式。 对于平均值汇总没有意义，平均值理论应该是先汇总在求值，除非增加新的请求，即使你只要计数和汇总，Metabase聚合是公共组件，就得特殊处理，所以这个确实影响Metabase的标准化 r-hot用js进行了实现，但是存在js精度不够导致的数据偏差 r-hot对性能进行了优化 有人热衷，有人关注 open了很长时间 最终还是关闭了 这个PR转眼已经过去一年多了，从代码提交来看甚至更早了，所以这个是在v0.33版本（新版本）之前的版本上（大概是v0.30版本）上进行改造的，关于版本历史和v0.33版本可以一查看我的Metabase系列里面文章的介绍。不管怎么说这个pr还是值得关注的，尽管平均值汇总的问题和Metabase标准化的问题不可避免的会存在。 ​ 这个版本你可以下载下来跑起来看，关于最新版本上的效果，下一篇文章会给出解决方案。这篇重点还是介绍这个pr。既然需求有，或许早晚会出来一版，如果有需求也可以先用r-hot这个版本的实现，一些汇总统计的需求还是满足的。 ​ sql查询效果图： Metabase透视表展示Metabase透视表是现有的功能，感觉就像交叉表，复杂表头不支持。 必须是两个分组列，才默认开启，可以关闭 超过两个分组列，不支持透视表 新版透视表如下： 旧版效果图：]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列07：V0.33版本焕然一新]]></title>
    <url>%2F2020%2F01%2F15%2Fmetabase-bi-v033%2F</url>
    <content type="text"><![CDATA[概述2019年4月23日，Metabase官方发布声明，已获得A轮融资，NEA向Metabase投资了800万美元。很重要的一点是NEA具有与Tableau（关于tableau有兴趣可以去官网下载demo）进行孵化和合作的经验，与MongoDB，Elastic，Nginx和Databricks等开源公司有广泛合作经验。 而且Metabase过去的一年中悄悄的发布企业版，虽然在Metabase企业版在论坛中已不是什么秘密，但是Metabase还是强调构建最好的开源产品始终是Metabase的重点。 很快Metabase于2019年6月24发布了v0.33 preview（预览版），8月19日发布v0.33正式版，并在12月19日双旦之前发布v0.34Holiday（假日版），通过v0.33预览版之后，会发现真的是焕然一新。 目前网上流通的Metabase相关的资料绝大部分都是v0.33之前版本，所以在此强调一下，v0.33不仅新而且值得一提，对于Metabase的意义也足够重要，所以将此版本单独写出来。 更新记录表 序号 版本 版本变化 描述 1. V0.33 Preview 查询生成器 1、创建关联表重构 2、分阶段进行数据聚合、分组、过滤、自定义字段等 2. V0.33 Preview 探索模式 1、数据可视化功能重构 2、汇总聚合功能调整 3. V0.33 Preview UI更新 1、表格样式重新定义和调整 2、过滤器工作方式调整 3、数据呈现调整等等 4. V0.33 Preview 删除sql预览功能 去除功能，调整查询生成器中 5. V0.33 查看表和可视化模式切换 数据展示界面，增加表格和可视化两种数据切换模式 6. V0.33 导航栏浏览数据源 快捷入口，减少返回主页等中间操作 7. V0.33 增强搜索 包括问题、仪表板以及更细分，搜索功能加强 8. V0.33 翻译政策调整 制定新的翻译策略 9. V0.34 Holiday 显示数据点上的值 查看条形图时，我们将自动为您显示这些点上方的值 10. V0.34 Holiday 新增mongo变量 允许在本机（SQL）查询中使用变量 11. V0.34 Holiday 时区修复 1、 数据库驱动时区调整 2、 时间处理时区问题调整 12. V0.34 Holiday SQL编辑器升级 1、 调整编辑器大小 2、 变量面板增加新图层 版本变化旧版本：V0.33预览版之前版本 新版本：V0.33预览版及之后版本 旧版UI 新版UI数据、聚合等功能集成到生成器，隐藏后与旧版比较更加简洁，旧版功能集成在上方占据空间，但是各有所爱 旧版生成器生成器是v0.33版本的叫法，旧版没有，我们姑且把数据、筛选、聚合、分组等功能都算在生成器里面 新版生成器新版生成器好像隐藏起来，像帘子上下展开而非弹窗的形式。 新版动态图展示 旧版图表显示 新版图表显示 旧版设置弹窗是形式 新版设置去掉原来弹窗模式 旧版下载 新版下载 新版数据源入口增加快速数据入口 新版搜索增强搜索功能 新版图表和数据切换新版图表和实际数据能够快速切换 新版优化sql查询]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列06：历史版本总结]]></title>
    <url>%2F2020%2F01%2F14%2Fmetabase-bi-his%2F</url>
    <content type="text"><![CDATA[​ 写这个内容的目的有两个： 最近对Metabase BI使用进行了一个梳理，包括二次开发的一个梳理 Metabase近来发布的0.33、0.34版本，变化较大，目前网上大部分你能搜到的，版本都是0.33之前的版本 ​ 所以以此为题，写了一篇，也为后面写一篇（Metabase-BI系列07：V0.33版本焕然一新）做个铺垫。 ​ 从Metabase官网上对历史版本从头到尾过了一遍，历史总能给人更好的回忆和警醒。就像只有通过看历史战争片，才能体会今天的幸福来之不易，通过Metabase的发版历史，同样能看出Metabase BI一步一步的变化和艰辛的发展。虽然无法体会历史场景的那一刻，但是可以了解当前的珍贵。少喝鸡汤，多写总结。 大版本Metabase开源以来，一共三个大版本，并在2019年4月23日推出企业版，当然是为了更快的发展和更好的发展。 v0.1x版本：开源，注重快速安装，功能略简陋，但五脏俱全，十个亿数据量分析测试，独特的分析图表的风格，吸引了大量用户使用并参与二次开发。 v0.2x版本：性能和功能逐步完善的版本，引入x-ray这种机器思想，可以看出0.2x版本对市面上的机器学习进行了研究分析，虽然没有突破BI的局限，但是确实也让人耳目一新。 v0.3x版本：逐渐成熟的版本，并在0.33版本进行了焕然一新的改动，在BI市场泛滥的时候，Metabase用其独特的风格吸引更多人关注，查询分析器、界面UI的改变确实很给力，详细介绍大家可以看我下一篇的文章。 版本明细v0.1x版本 v0.2x版本 v0.3x版本]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列05： 错误Unknown system variable 'session_track_schema']]></title>
    <url>%2F2019%2F11%2F29%2Fmetabase-bi-bug01%2F</url>
    <content type="text"><![CDATA[Metabase连接mysql5.6.16-log版本数据库报错：Unknown system variable ‘session_track_schema’ 情况一：Metabase启动数据库为mysql5.6.16启动直接报错，启动失败 Metabase在启动时报错session_track_schema，日志文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146while i&apos;m executingexport MB_DB_CONNECTION_URI=&quot;mysql://...&quot;; java -jar metabase.jarwith mysql server version of 5.6.16i&apos;ve got this exception05-13 18:58:09 INFO metabase.util :: Loading Metabase...05-13 18:58:09 INFO metabase.util :: Maximum memory available to JVM: 3.4 GB05-13 18:59:54 INFO util.encryption :: Saved credentials encryption is DISABLED for this Metabase instance. ?For more information, see https://metabase.com/docs/latest/operations-guide/start.html#encrypting-your-database-connection-details-at-rest05-13 19:02:25 INFO metabase.driver :: Registered abstract driver :sql ?05-13 19:07:27 INFO metabase.core :: Starting Metabase in STANDALONE mode05-13 19:07:30 INFO metabase.server :: Launching Embedded Jetty Webserver with config:&#123;:port 10080, :host &quot;0.0.0.0&quot;&#125;05-13 19:07:34 INFO metabase.core :: Starting Metabase version v0.32.7 ([`e309f28`](https://github.com/metabase/metabase/commit/e309f2875ca0ffd87da5fb1666260b0ab257860d) release-0.32.x) ...05-13 19:07:34 INFO metabase.core :: System timezone is &apos;Asia/Shanghai&apos; ...05-13 19:07:34 INFO metabase.plugins :: Loading plugins in /home/lhladmin/metabase/plugins...05-13 19:07:40 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :hive-like...05-13 19:07:40 DEBUG plugins.classloader :: Setting current thread context classloader to NEWLY CREATED classloader clojure.lang.DynamicClassLoader@79ca51cb...05-13 19:07:42 INFO metabase.driver :: Registered abstract driver :sql-jdbc (parents: :sql) ?Load driver :sql-jdbc took 2 s05-13 19:07:43 INFO metabase.driver :: Registered abstract driver :hive-like (parents: #&#123;:sql-jdbc&#125;) ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :sparksql...05-13 19:07:43 INFO metabase.driver :: Registered driver :sparksql (parents: #&#123;:hive-like&#125;) ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :druid...05-13 19:07:43 INFO metabase.driver :: Registered driver :druid ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :snowflake...05-13 19:07:43 INFO metabase.driver :: Registered driver :snowflake (parents: #&#123;:sql-jdbc&#125;) ?05-13 19:07:43 INFO plugins.dependencies :: Metabase cannot initialize plugin Metabase Oracle Driver due to required dependencies. Metabase requires the Oracle JDBC driver in order to connect to Oracle databases, but we can&apos;t ship it as part of Metabase due to licensing restrictions. See https://metabase.com/docs/latest/administration-guide/databases/oracle.html for more details.05-13 19:07:43 INFO plugins.dependencies :: Metabase Oracle Driver dependency &#123;:class oracle.jdbc.OracleDriver&#125; satisfied? false05-13 19:07:43 INFO plugins.dependencies :: Plugins with unsatisfied deps: [&quot;Metabase Oracle Driver&quot;]05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :google...05-13 19:07:43 INFO metabase.driver :: Registered abstract driver :google ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :presto...05-13 19:07:43 INFO metabase.driver :: Registered driver :presto (parents: #&#123;:sql&#125;) ?05-13 19:07:43 INFO plugins.dependencies :: Metabase cannot initialize plugin Metabase Vertica Driver due to required dependencies. Metabase requires the Vertica JDBC driver in order to connect to Vertica databases, but we can&apos;t ship it as part of Metabase due to licensing restrictions. See https://metabase.com/docs/latest/administration-guide/databases/vertica.html for more details.05-13 19:07:43 INFO plugins.dependencies :: Metabase Vertica Driver dependency &#123;:class com.vertica.jdbc.Driver&#125; satisfied? false05-13 19:07:43 INFO plugins.dependencies :: Plugins with unsatisfied deps: [&quot;Metabase Vertica Driver&quot; &quot;Metabase Oracle Driver&quot;]05-13 19:07:43 INFO plugins.dependencies :: Plugin &apos;Metabase BigQuery Driver&apos; depends on plugin &apos;Metabase Google Drivers Shared Dependencies&apos;05-13 19:07:43 INFO plugins.dependencies :: Metabase BigQuery Driver dependency &#123;:plugin Metabase Google Drivers Shared Dependencies&#125; satisfied? true05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :bigquery...05-13 19:07:43 INFO metabase.driver :: Registered driver :bigquery (parents: #&#123;:sql :google&#125;) ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :sqlite...05-13 19:07:43 INFO metabase.driver :: Registered driver :sqlite (parents: #&#123;:sql-jdbc&#125;) ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :sqlserver...05-13 19:07:43 INFO metabase.driver :: Registered driver :sqlserver (parents: #&#123;:sql-jdbc&#125;) ?05-13 19:07:43 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :redshift...05-13 19:07:43 INFO metabase.driver :: Registered driver :postgres (parents: :sql-jdbc) ?Load driver :postgres took 1 s05-13 19:07:44 INFO metabase.driver :: Registered driver :redshift (parents: #&#123;:postgres&#125;) ?05-13 19:07:44 INFO plugins.dependencies :: Plugin &apos;Metabase Google Analytics Driver&apos; depends on plugin &apos;Metabase Google Drivers Shared Dependencies&apos;05-13 19:07:44 INFO plugins.dependencies :: Metabase Google Analytics Driver dependency &#123;:plugin Metabase Google Drivers Shared Dependencies&#125; satisfied? true05-13 19:07:44 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :googleanalytics...05-13 19:07:44 INFO metabase.driver :: Registered driver :googleanalytics (parents: #&#123;:google&#125;) ?05-13 19:07:44 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :mongo...05-13 19:07:44 INFO metabase.driver :: Registered driver :mongo ?05-13 19:07:46 INFO metabase.driver :: Registered driver :mysql (parents: :sql-jdbc) ?Load driver :mysql took 2 s05-13 19:07:48 INFO metabase.driver :: Registered driver :h2 (parents: :sql-jdbc) ?Load driver :h2 took 1 s05-13 19:07:49 INFO metabase.core :: Setting up and migrating Metabase DB. Please sit tight, this may take a minute...05-13 19:07:49 INFO metabase.db :: Verifying mysql Database Connection ...05-13 19:07:49 INFO metabase.driver :: Initializing driver :sql...05-13 19:07:49 INFO metabase.driver :: Initializing driver :sql-jdbc...05-13 19:07:49 INFO metabase.driver :: Initializing driver :mysql...05-13 19:07:52 ERROR metabase.core :: Metabase Initialization FAILEDjava.lang.Exception: java.sql.SQLException: Unknown system variable &apos;session_track_schema&apos;at metabase.driver.util$can_connect_with_details_QMARK_.invokeStatic(util.clj:34)at metabase.driver.util$can_connect_with_details_QMARK_.doInvoke(util.clj:18)at clojure.lang.RestFn.invoke(RestFn.java:442)at clojure.lang.Var.invoke(Var.java:393)at metabase.db$verify_db_connection$fn__16148.invoke(db.clj:403)at metabase.db$verify_db_connection.invokeStatic(db.clj:401)at metabase.db$verify_db_connection.invoke(db.clj:394)at metabase.db$verify_db_connection.invokeStatic(db.clj:397)at metabase.db$verify_db_connection.invoke(db.clj:394)at metabase.db$setup_db_BANG_$Missing open brace for subscriptfn__16165.invoke(db.clj:467)at metabase.util$do_with_us_locale.invokeStatic(util.clj:676)at metabase.util$do_with_us_locale.invoke(util.clj:662)at metabase.db$setup_db_BANG_.invokeStatic(db.clj:466)at metabase.db$setup_db_BANG_.doInvoke(db.clj:460)at clojure.lang.RestFn.invoke(RestFn.java:421)at metabase.core$init_BANG_.invokeStatic(core.clj:77)at metabase.core$init_BANG_.invoke(core.clj:56)at metabase.core$start_normally.invokeStatic(core.clj:123)at metabase.core$start_normally.invoke(core.clj:117)at metabase.core$*main.invokeStatic(core.clj:143)at metabase.core$\*main.doInvoke(core.clj:138)at clojure.lang.RestFn.invoke(RestFn.java:397)at clojure.lang.AFn.applyToHelper(AFn.java:152)at clojure.lang.RestFn.applyTo(RestFn.java:132)at metabase.core.main(Unknown Source)Caused by: java.util.concurrent.ExecutionException: java.sql.SQLException: Unknown system variable &apos;session_track_schema&apos;at java.util.concurrent.FutureTask.report(FutureTask.java:122)at java.util.concurrent.FutureTask.get(FutureTask.java:206)at clojure.core$deref_future.invokeStatic(core.clj:2302)at clojure.core$future_call$Missing open brace for subscriptreify__8439.deref(core.clj:6974)at clojure.core$deref.invokeStatic(core.clj:2324)at clojure.core$deref.invoke(core.clj:2306)at metabase.util$deref_with_timeout.invokeStatic(util.clj:328)at metabase.util$deref_with_timeout.invoke(util.clj:324)at metabase.driver.util$can_connect_with_details_QMARK\*.invokeStatic(util.clj:29)... 24 moreCaused by: java.sql.SQLException: Unknown system variable &apos;session_track_schema&apos;at org.mariadb.jdbc.internal.util.exceptions.ExceptionMapper.get(ExceptionMapper.java:255)at org.mariadb.jdbc.internal.util.exceptions.ExceptionMapper.getException(ExceptionMapper.java:165)at org.mariadb.jdbc.internal.protocol.AbstractConnectProtocol.connectWithoutProxy(AbstractConnectProtocol.java:1199)at org.mariadb.jdbc.internal.util.Utils.retrieveProxy(Utils.java:560)at org.mariadb.jdbc.MariaDbConnection.newConnection(MariaDbConnection.java:174)at org.mariadb.jdbc.Driver.connect(Driver.java:92)at java.sql.DriverManager.getConnection(DriverManager.java:664)at java.sql.DriverManager.getConnection(DriverManager.java:208)at clojure.java.jdbc$get_driver_connection.invokeStatic(jdbc.clj:271)at clojure.java.jdbc$get_driver_connection.invoke(jdbc.clj:250)at clojure.java.jdbc$get_connection.invokeStatic(jdbc.clj:411)at clojure.java.jdbc$get_connection.invoke(jdbc.clj:274)at clojure.java.jdbc$db_query_with_resultset_STAR*.invokeStatic(jdbc.clj:1093)at clojure.java.jdbc$db_query_with_resultset_STAR_.invoke(jdbc.clj:1075)at clojure.java.jdbc$query.invokeStatic(jdbc.clj:1164)at clojure.java.jdbc$query.invoke(jdbc.clj:1126)at clojure.java.jdbc$query.invokeStatic(jdbc.clj:1142)at clojure.java.jdbc$query.invoke(jdbc.clj:1126)at metabase.driver.sql_jdbc.connection$can_connect_QMARK_.invokeStatic(connection.clj:123)at metabase.driver.sql_jdbc.connection$can_connect_QMARK_.invoke(connection.clj:118)at metabase.driver.sql_jdbc$Missing open brace for subscriptfn__62793.invokeStatic(sql_jdbc.clj:39)at metabase.driver.sql_jdbc$fn__62793.invoke(sql_jdbc.clj:38)at clojure.lang.MultiFn.invoke(MultiFn.java:234)at metabase.driver.util$can_connect_with_details_QMARK_$Missing open brace for subscriptfn__18037.invoke(util.clj:30)at clojure.core$binding_conveyor_fn$Missing open brace for subscriptfn__5739.invoke(core.clj:2030)at clojure.lang.AFn.call(AFn.java:18)at java.util.concurrent.FutureTask.run(FutureTask.java:266)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)at java.lang.Thread.run(Thread.java:748)Caused by: java.sql.SQLException: Unknown system variable &apos;session_track_schema&apos;at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readErrorPacket(AbstractQueryProtocol.java:1587)at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readPacket(AbstractQueryProtocol.java:1445)at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.getResult(AbstractQueryProtocol.java:1407)at org.mariadb.jdbc.internal.protocol.AbstractConnectProtocol.additionalData(AbstractConnectProtocol.java:730)at org.mariadb.jdbc.internal.protocol.AbstractConnectProtocol.connect(AbstractConnectProtocol.java:542)at org.mariadb.jdbc.internal.protocol.AbstractConnectProtocol.connectWithoutProxy(AbstractConnectProtocol.java:1195)... 27 more05-13 19:07:52 INFO metabase.core :: Metabase Shutting Down ...05-13 19:07:52 INFO metabase.server :: Shutting Down Embedded Jetty Webserver05-13 19:07:53 INFO metabase.core :: Metabase Shutdown COMPLETE 情况二：添加数据源mysql5.6.16如果数据源是这个版本也会同样的问题： 这个问题是数据库版本导致的，你看一下详细查看Metabase github的issue：9483的讨论 关于这个问题Metabase上的issue特别的多，而且容易看晕，最后终于在找到了一个解决办法，亲测可用 最终解决方案，你可以看一下（见issue：9954）： 分析原因-session-track-schema至于MariaDB是MySQL 的一个 branch，还是MariaDB 是 MySQL 的一个fork先不讨论，不过它俩似乎一直就存在兼容性的问题，Metabase MySQL/MariaDB driver是mariadb-java-client这个包。 Metabase不支持Alibaba RDS MySQL 5.6.16-log，因为在0.32.0版本中更改为MariaDB Connector/J，因为旧MySQL不支持session-track-schema。 后来发现就是这个5.6.16-log这个小版本有问题，目前其他的版本未发现存在问题。 解决办法-mariadb-java-client包首先确定Metabase使用的MySQL/MariaDB driver版本，到project下面 1[org.mariadb.jdbc/mariadb-java-client &quot;2.3.0&quot;] ; MySQL/MariaDB driver 需要下载源码包：mariadb-java-client-2.3.0-sources.jar（Metabase当前版本用的这个版本） 123456789101112131415161718AbstractConnectProtocol.java-542行注释掉if (options.usePipelineAuth &amp;&amp; !options.createDatabaseIfNotExist) &#123; try &#123; sendPipelineAdditionalData(); readPipelineAdditionalData(serverData); &#125; catch (SQLException sqle) &#123; if (&quot;08&quot;.equals(sqle.getSQLState())) &#123; throw sqle; &#125; //in case pipeline is not supported //(proxy flush socket after reading first packet) //解决mysql5.6.16-log版本，session_track_schema问题 //additionalData(serverData); &#125; &#125; else &#123; additionalData(serverData); &#125; 编译完替换就重新启动即可，也可以直接下载我编译完的 AbstractConnectProtocol.class]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列04：cookie实现单点登录sso]]></title>
    <url>%2F2019%2F11%2F29%2Fmetabase-bi-cookie%2F</url>
    <content type="text"><![CDATA[概述​ Metabase 可以作为独立的BI平台，本身就有用户组和权限组。而且Metabase支持报表的分享和iframe嵌入的方式进行报表的呈现，我们可以通过这种方式进行数据的呈现。 ​ 我们需要登录Metabase系统进行报表创建和发布，如果业务平台有权限的用户想通过业务平台用户进入到Metabase里面，就需要进行单点登录，因为用户不可能登录两个平台用两个账户，当然如果用户能够接受，那就可以用两个账户了。 ​ Metabase支持多种单点登录（sso）方式： Google账号登录，这种方式在中国只能呵呵了 LDAP的方式，需要搭建一个LDAP统一认证的服务，这个麻烦点，Metabase提供配置LDAP功能，比较方便 基于SAML协议接入单点登录， SAML即安全断言标记语言，这个不是很熟，可以尝试一下 通过cookie实现单点，操作简单，但是比较受限，安全性低 这里介绍通过cookie实现简单的单点登录 Metabase-cookiemetabase.SESSION_ID首先看一下Metabase里面的cookie， metabase.SESSION就是Metabase访问权限的令牌，path为“/”根目录下面，所以获取令牌，将把令牌塞到metabase.SESSION里就可以了。 /api/session/Metabase doc API说明如下： 12345## `POST /api/session/`**Login.**##### PARAMS:**\* ***\*****`username`*****\*** value must be a non-blank string.\* ***\*****`password`*****\*** value must be a non-blank string. 所以，我们需要调用/api/session/，传入用户和密码，获取令牌 跨域问题直接访问Metabase的/api/session会存在跨域的问题 修改Metabase后台允许跨域，Metabase后台用的Ring框架控制跳转，我们引入开源的ring-cors框架，配置允许跨域的域和请求，配置Metabase的handler.clj 1234(require &apos;[ring.middleware.cors :refer [wrap-cors]])(def handler (wrap-cors my-routes :access-control-allow-origin [#&quot;http://example.com&quot;] :access-control-allow-methods [:get :put :post :delete])) cookie共享问题对于cookie来说，不同域下的cookie不共享，必须在同个顶级域下设置cookie，所以这也是这种cookie实现单点比较受限制的问题。 对于统一域名不同端口的情况，直接将cookie放到path根目录“/”即可，因为域是相同的 对于不同的二级域名的情况，放到顶级域名下即可 如：aa.test.com和bb.test.com 1Cookies.set(&apos;metabase.SESSION&apos;, token, &#123; path: &apos;/&apos;,domain: &apos;.test.com&apos; &#125;) 关于cookie的介绍，推荐文章： https://www.cnblogs.com/hujunzheng/p/5744755.html]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列03：win系统用git-bash启动Metabase]]></title>
    <url>%2F2019%2F11%2F08%2Fmetabase-bi-gitbash%2F</url>
    <content type="text"><![CDATA[由于windows下启动Metabase存在不友好情况，启动linux消耗系统性能，影响工作效率，巧妙借助git-bash来启动Metabase，既可以避免windows下的坑，还特别的轻量级，甚至比cmd、vscode等命令窗口下启动都要快。 概述git目前最好用的版本控制器了，github、gitlib、coding、码云等代码托管平台，都使用的git，而且git本身就是用于linux内核开发的版本控制工具。所以大部分开发者本身就用，只要装了git，就带有git-bash，就在git的安装目录下面。 windows下cmd命令的文件格式：E:\Profile Files，git-bash下：/e/Profile Files，是不是很像linux。 git-bash启动Metabase其实很简单，就是进到Metabase目录下面启动，唯一需要注意的就是leiningen，leiningen是Metabase的项目构建和项目启动的组件，windows下安装配置是bat命令，所以直接在git-bash下，直接启动是找不到lein命令的。 在Metabase-BI系列01：二次开发环境(windows)搭建下提到过leiningen的安装，直接福复制的命令，创建了个bat文件，这里你就需要下载官网的lein script，直接网页搜索lein script就能快速找到，这个是linux的lein的脚本命令，不需要扩展名，名称lein就可以，把脚本命令复制lein安装目录/bin进去，其他步骤一样，同样需要leiningen-2.9.1-standalone.jar。 如果是用的zip包安装的，本身bin下面就有了lein这个linux脚本命令，只需要下载或者直接打包leiningen-core-2.9.1.jar，放到安装目录/self-installs下，缺少jar包会报缺少依赖错误。 别忘了windows下面配置环境变量，如果需要在git-bah下配置环境变量应该也可以，环境变量位置：git安装目录/etc/profile，配置完需执行命令，使其生效 12export LEIN_HOME=/e/metabase/lein/leiningen-2.9.1export PATH=$LEIN_HOME/bin:$PATH 1source /安装目录/etc/profile 可以通过如下命令，查看环境变量是否生效 12echo %LEIN_HOEM% //windows下echo $LEIN_HOME //git-bash下 安装完启动lien run git-bash打包Metabase驱动包Metabase目录有个module/dirviers模块，下面放着mongo、oracle、sparksql等数据库驱动项目，可以直接到各个驱动下面执行lein uberjar 如果在git-bash下，我们就可以到Metabase安装目录下，执行命令，注意一定是安装目录下而不是安装目录bin下面 12345#Metabase的doc下有说明# Build the &apos;mongo&apos; driver 单独执行一个驱动./bin/build-driver.sh mongo# Build all drivers 打包所有驱动./bin/build-drivers.sh git-bash打包转换语言包Metabase安装目录/bin/build-translation-frontend-resource文件，进行语言包po到json的转换 Metabase语言包（po）位置：Metabase安装目录/local 用法： 1./bin/i18n/build-translation-frontend-resource input.po output.json git-bash缺点git-bash目前发现唯一的一个缺点就是，控制台日志查找不方便，不如vscode直接在控制台ctr+f就能查找定位。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列02：二次开发环境(windows)踩坑]]></title>
    <url>%2F2019%2F11%2F06%2Fmetabase-bi-pit%2F</url>
    <content type="text"><![CDATA[由于github源代码开发者用的linux或者mac来作为开发环境，所以存在windows环境下的不友好，有的甚至就是坑。甚至好多Metabase windows开发者也是用linux虚拟机来跑环境的。 当然如果通过虚拟机跑linux，或者用windows自带的Ubuntu进行开发，有些问题就不存在了，还有一种好的方式用git的bash环境去搭建，可参见：Metabase-BI系列03：win系统用git-bash启动Metabase。 坑一：git-clone源码编码LF问题git里面有 AutoCRLF 、 SafeCRLF 123456git config --global core.autocrlf true //提交转换为LF，检出转换为CRLF git config --global core.autocrlf false //提交检出都不转换 git config --global core.autocrlf input //提交转换为LF，检出不转换 git config --global core.safecrlf true //拒绝提交包含混合换行符文件 git config --global core.safecrlf false //允许提交包含混合换行符文件 git config --global core.safecrlf warn //提交包含混合换行符文件给出警告 如果： AutoCRLF 设置为ture，代码转换成CRLF，代码后台能跑起来，前台web端访问空白，js错误，各种property undefined 所以这种情况一定要将AutoCRLF 设置为false，而且是先设置false，再执行git clone 可以肯定的一点是，本身LF转CRLF就存在bug，所以就很容易出问题 坑二：yarn install时grep命令问题在install的时候，要去掉grep那条命令，此命令为linux命令，可见完全没有考虑windows环境的感受，当然你也可以尝试安装grep在windows下执行的程序 1&quot;preinstall&quot;: &quot;echo $npm_execpath | grep -q yarn || echo &apos;\\033[0;33mSorry, npm is not supported. Please use Yarn (https://yarnpkg.com/).\\033[0m&apos;&quot;, 坑三：NODE_ENV不是内部或外部命令在install的时候，NODE_ENV不是内部或者外部命令，其实这个还是linux和windows的问题 12linux： NODE_ENV=hot windows: set NODE_ENV=hot 所以说windows下，直接加个set就可以了，或者去掉里面的，先set变量，再install。 注意：这个是热部署的变量，如果需要热部署，这个命令不能少。 坑四：lein ring server文件名扩展名报错123Compilation failed: Cannot run program &quot;java&quot; (in directory &quot;D:\metabase&quot;): CreateProcess error=206, 文件名或扩展名太长。Error encountered performing task &apos;ring&apos; with profile(s): &apos;base,system,user,provided,dev,ring&apos;Compilation failed: Cannot run program &quot;java&quot; (in directory &quot;D:\metabase&quot;): CreateProcess error=206, 文件名或扩展名太长。 这个问题是windows系统导致的，如果是win10或许可以解除这个长度限制，如果是win7或者更早的windows版本估计不好解决，就不能用热部署了，但是lein run是可以的 坑五：自动创建仪表板(数据透视)的问题登录首页后，一直发请求，html 500错误 123Request URL: http://localhost:3000/api/automagic-dashboards/database/2/candidatesRequest Method: GETStatus Code: 500 Server Error 后台报错，找不到目录文件 很明显是windows路径错误，可以特殊处理一下，找到src/metabase/util/files.clj 1234567891011(defn do-with-open-path-to-resource &quot;Impl for `with-open-path-to-resource`.&quot; [^String resource, f] (let [url (io/resource resource)] (when-not url (throw (FileNotFoundException. (trs &quot;Resource does not exist.&quot;)))) (if (url-inside-jar? url) (with-open [fs (jar-file-system-from-url url)]​ (f (get-path-in-filesystem fs &quot;/&quot; resource))) ; windows下修复数据透视路径subs去掉前缀 (f (get-path (subs (.getPath url) 1)))))) 坑六：数据源、中文汉化包不自动生成问题正常情况下会在，安装目录/plugins下生成数据库驱动包，如果没有新增数据库只能选择默认的几种数据库类型 正常情况下，安装目录/resources/frontend_client/app/locales下，生成多语言版本json windows下有些shell脚本命令是不能正常运行的，所以导致不能正常生成，可以直接下载放到相应目录底下，数据库驱动包也可以到module各个驱动目录下面直接lein uberjar生成，这种生成容易发生依赖包不一致报错的问题。 问题七：Metabase多版本jar包冲突Metabase里面有很多分支，有些是版本分支，如果用到新老板，就不要把不同版交叉使用，Metabase在运行时正常会检测并清理，一旦出现检查存在又不进行清除更新就会出现jar包冲突。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metabase-BI系列01：二次开发环境(windows)搭建]]></title>
    <url>%2F2019%2F11%2F04%2Fmetabase-bi-dev%2F</url>
    <content type="text"><![CDATA[概述Metabase 官网介绍：是一种简单、开源的方式，让公司中的每个人都可以通过它来提问和学习数据。 如果了解更多BI工具，可看我的另一篇文章：BI、数据可视化工具浅析整理。 Metabase特点： 开源免费 适合看运行数据： 提问的方式，业务人员自己就可以做数据分析 报表自动化，数据可视化 权限管理控制 数据共享，操作简单 可以与ETL结合 支持与业务系统做集成 二次开发前端框架：React + Redux等相关框架，基于yarn的开发环境，webpack构建 后端开发：metabase后端语言采用clojure，Ring和toucan等开发框架 补充： 前端框架：React + Redux + D3（图表工具） 后端框架：Clojure + RING（中间件） + Compojure（路由框架） + Toucan（ORM框架） 源代码github地址： https://github.com/metabase/metabase 安装git工具，clone源代码 开发工具 idea 需安装clojure相关插件， Cursive和Leinigen vscode 安装 calva和clojure插件 安装工具LeiningenLeiningen用于自动化Clojure项目，例如创建项目、抓取依赖包、编译、运行、测试、此外，Leiningen可以为项目生成maven风格的“pom”文件以进行互操作。 安装过程： 第一步： 官网下载zip包和bat文件 第二步： 自定义Leiningen安装目录，并在安装目录下面，创建bin文件夹和self-installs文件夹 将bat文件，lein.bat放到bin目录下面 将zip包修改后缀为jar，然后放到self-installs文件夹中，如：leiningen-2.9.1-standalone.jar 备注：也可以直接找安装版安装即可 第三步： 配置环境变量，创建LEIN_HOME变量，配置%LEIN_HOME%\bin目录到path中 运行命令lein repl :start，该命令会先启动REPL服务端，接着启动REPL客户端连接所启动的REPL服务端 到此，Leiningen安装到了windows上 yarn下载地址：https://yarnpkg.com/en/docs/install nodejs安装最新版本 部署发布windows二次开发环境部署，采用yarn，不建议用npm，容易出问题，推荐编辑工具vscode 初始化 1yarn install 前端编译 1yarn run build 后端运行 1lein run 访问默认端口3000 http://localhost:3000 有个配置引导，数据可以直接选稍后配置，其余下一步即可 Metabase自身默认数据库修改Metabase默认使用的H2数据库，如果想改用本地mysql需要，修改环境变量（或者启动之前设置一下），如果直接运行不生效，建议重启一下电脑 123456set MB_DB_TYPE=mysqlset MB_DB_DBNAME=metabaseset MB_DB_PORT=3306set MB_DB_USER=rootset MB_DB_PASS=123456set MB_DB_HOST=localhost 注意一：myql数据库创建用utf-8，utf8mb4有可能出现问题 注意二：如果碰到 1709 – 索引列大小太大.最大列大小为767字节问题 12345678//查看SHOW VARIABLES LIKE &apos;storage_engine&apos;;//默认应该是MyISAM，修改为InnoDB，这个修改最好改配置文件SHOW variables like &apos;innodb_large_prefix&apos;SHOW variables like &apos;innodb_file_format&apos;//修改SET GLOBAL INNODB_LARGE_PREFIX = ON;SET GLOBAL INNODB_LARGE_PREFIX = ON;SET GLOBAL innodb_file_format = BARRACUDA; Metabase默认DEMO数据库+H2工具Metabase默认是数据库是H2数据库，连接工具直接去H2官网下载即可 连接配置，你可以直接到Metabase本身数据里面去找，表：metabase_database 1&#123;&quot;db&quot;:&quot;/E:/XXXX/metabase-master/resources/sample-dataset.db;USER=GUEST;PASSWORD=guest&quot;&#125; 可以直接看到数据库，用户名和密码，注意配置连接直接访问数据库文件就可以，不能多个应用同时访问 常用命令lein repl：打开REPL环境。 前端编译：yarn build 前端热部署：yarn build-hot 后端运行：lein run 后端热部署：lein ring server lein uberjar：打包项目，包含依赖项。得到jar后就跟平常的jar没有区别了。]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BI、数据可视化工具浅析整理]]></title>
    <url>%2F2019%2F11%2F03%2Fmetabase-bi-datav%2F</url>
    <content type="text"><![CDATA[AI（ Artificial Intelligence ）：人工智能 BI（ Business Intelligence ）：商业智能 BI商业智能，个人感觉商业化了一些，而且感觉没有把数据的价值体现的名称上，也不知道为什么不直接一点叫DI（Data Intelligence ）。 AI和BI似乎不可分割，起码相辅相成。AI似乎更火热，BI提出更早一些，似乎有点过气和传统的感觉，但是想想，可视化数据展示、数据可视化，这些名词或许目前更流行，其实应该都算是BI的变种，个人感觉似乎又有点去商业化，起码不叫什么商业可视化。 阿里云推出了大数据和人工智能DataV数据可视化、 Quick BI等等产品，且不说做到什么程度，加上手机、大屏的时代发展，就会发现数据的价值也越来越大。 由于工作对BI牵扯甚多，近来使用Metabase，准备写一下Metabase系列，就已BI、数据可视化做引子，查找资料总结了一下，后续会更新修改。这里不讲AI，不谈商业，通过搜索网上资料进行整理，就说一下接触的或者市面上BI、数据可视化的工具。 这里进行分类：重量级（商用+服务）、轻量级（开源）、商业级（服务），其它（心血来潮的一些小项目：GitDataV、DataVisualization） 重量级（商用+服务）IBM CognosIBM Cognos 起初是加拿大的一家公司，后来被IBM收购。功能非常强大，可以自身创建package、立方体数据模型，通过ETL工具进行数据清洗，然后定时抽取IBM Cognos模型，自身实现配置化集群和负载均衡等功能，能够处理大规模，多系统（财务、资金、业务、人力资源等等）数据，进行数据整合，配套工具完善且非常多，此外 扩展性比较强，尤其对多系统数据处理 权限、数据集成完善 网关、应用服务器、内容管理器组件灵活 比较重，数据量小就大材小用，一般建行等大企业用多 不知道现在是否支持nosql类型的数据库 支持导出备份及导入等操作 1、技术架构：java + BS架构 2、适用范围： ​ 政府单位、大型企业 3、安装部署： ​ weblogic、websphere、tomcat等集成部署 4、数据源：oracle、db2、mysql关系型数据库 5、可视化： 支持各种图表展示 支持各种下钻及功能性扩展 展示组件强大 6、支持文档： 安装文档齐全 集成部署补丁包完善 资料论坛可查找资料，因为大型企业使用，所以个人分享的资料较少 7、权限管理：支持权限控制 8、二次开发：利用cognos自身特性进行扩展及集成开发，源代码不开放 赛思赛思是国内用的比较多的BI工具，是武汉东方赛思软件公司开发的，目前政府、金融等单位使用的多。赛思大数据平台，为政府部门、企业或是IT公司的大数据项目提供全方位的平台支持。也有数据的提取、加工、调度等强大的功能。服务团队规模有保障，解决方案完善，但是目前对nosql数据库支持欠缺。 其他 Tableau Microsoft (Power BI) SAS (Visual Analytics) AWS(Athena and Kinesis) Google (Dataproc and Big Query) Fusionex (Giant) Zendesk (Zime) SAP（BO） Oracle（BIEE） 轻量级（开源）Supersetgithub地址： https://github.com/apache/incubator-superset 1、技术架构： 后端：Python + Flask（ Web 应用框架 ） +SQLAlchemy（orm框架） 前端：React + Redux +D3 2、适用范围： 开发/分析人员做好看板，业务人员浏览看板数据 业务人员可自行编辑图表，查看满足条件的结果 3、安装部署： ​ docker方式的安装部署最简单 4、数据源：支持各种数据源，包括Hive、Kylin等 5、可视化： 支持的图表类型多，达47种 图表可视化选项少，例如，数据格式选项偏少，如需添加，需要修改配置文件 可在看板中添加筛选框，支持在不同条件下查看 不支持图表和看板分组管理 没有提供图表的下钻功能，不支持多图表间的复杂联动 不支持跨库的表关联查询 支持其他图标库扩展 6、支持文档： 安装部署和快速入门方面的文档详细 但具体功能和图表制作方面的介绍文档需要搜索资料 整体文档资料相当简陋 7、邮件通知：不支持 8、权限管理： 报表权限设置较复杂、繁琐 可实现对菜单、数据源、数据表、字段、图表、看板等权限控制 10、二次开发： 支持 RESTful API 原属Airbnb的开源项目，有大公司团队维护，版本更新、Bug修复、二次开发有较大保障 也有说代码维护迭代，不活跃 Redashgithub地址： https://github.com/getredash/redash 1、技术架构：Python + Flask + AngularJS + SQLAlchemy 2、适用范围：由于是对SQL查询结果进行可视化，需要开发/分析人员做好看板，业务人员浏览看板数据。 3、安装部署： 安装部署相对较麻烦 参考部署文档 4、数据源：支持数据源比superset少，不支持Kylin 5、可视化： 支持的图表类型不如Superset多，仅12种 图表可视化选项多 不支持在看板种添加筛选框 不支持图表和看板分组管理 没有提供图表的下钻功能，不支持多图表间的复杂联动 不支持跨库的表关联查询 6、支持文档： 提供快速入门教程 每一个功能模块都有文档且条理清晰 7、邮件通知：支持定时发送邮件 8、权限管理：权限设置简单，仅控制用户组对数据源的权限（只有两个权限：Full access或View only） 9、二次开发： ​ 提供完整的 RESTful API 接口 10、源代码：代码质量比Superset要好，但比Metabase差一点 Metabasegithub地址： https://github.com/metabase/metabase 1、技术架构： 前端框架：React + Redux + D3（图表工具） 后端框架：Clojure + RING（中间件） + Compojure（路由框架） + Toucan（ORM框架） 2、适用范围： ​ 界面漂亮、友好，使用体验好，适合业务人员使用 3、安装部署： windows下安装部署非常简单 docker部署简单 4、数据源：支持数据源少（12种），不支持Hive、Kylin（硬伤） 5、创建步骤：连接数据源–&gt;图表–&gt;看板–&gt;定时任务 6、可视化： 支持的图表类型不如superset多，仅14种 图表可视化选项多，例如，提供数据格式多，设置灵活 可在看板中添加筛选框，支持在不同条件下查看 通过创建集合，支持图表、看板、定时任务分组管理 提供图表的简单钻取功能，不支持图表间的复杂联动 不支持跨库的表关联查询 7、支持文档： ​ 安装部署、快速入门、具体功能、API等方面的文档详细 8、邮件通知：支持定时发送邮件 9、权限管理： 权限设置单一，只有访问权限 仅实现对数据源、数据表、图表、集合等权限控制 10、二次开发：提供完整的API文档，即使完全不会 Clojure，依然可以凭借丰富的 API 与文档完成许多二次开发。 11、源代码： 代码质量最好，结构清晰，整洁度高 clojure语法，函数式编程，学习成本较高 Zeppelingithub地址：https://github.com/apache/zeppelin 严格意义上说，Zeppelin更像是一个notebook，而不是一个单纯的BI工具，来自Apache项目 1、技术架构： ​ 交互式数据分析开源框架，支持多种语言， 包括Scala、Python、SparkSQL、Hive、Markdown、Shell等 2、适用范围：似乎更适合开发人员 3、可视化：不支持sql查询 SQLPadgithub地址：https://github.com/rickbergfalk/sqlpad SQLPad是一个基于Nodejs开发的直接在浏览器运行SQL查询并对结果进行可视化展示工具 1、适用范围：适合开发人员 2、数据源： MySQL, Postgres, SQL Server, Vertica, Crate, Presto等 3、可视化：特别支持sql，与Zeppelin不同，看名字就能看出来 CBoardgithub地址：https://github.com/yzhang921/CBoard 1、技术架构： 后端：Spring+MyBatis 前端： ngularJS1和Bootstrap 2、特点： 国人开发的一款可视化工具 交互设计的不错，但是感觉有点奇怪 Java系 Davincigithub地址： https://github.com/edp963/davinci 1、技术架构：宜信开发的达芬奇，Java 2、可视化：功能还是比较全面的，只是在国内还没有大范围的使用 商业级（服务）FineBI1、技术架构：java开发 后端：spring mvc + Hibernate 前端：fineui 2、适用范围： 开发/数据人员准备好数据，数据人员/业务人员分析。 业务人员完全可自行分析、制作可视化。整个数据分析流程分工明确。 3、安装部署： ​ 直接官网下载电脑适配的版本安装激活即可 4、数据源：支持各种数据源，Apache Kylin、Derby、HP Vertica、IBM DB2、Informix、Sql Server、MySQL、Oracle、Pivotal Greenplum Database、Postgresql、ADS、Amazon Redshift、Apache Impala、Apache Phoenix、Gbase 8A、Gbase8S、Gbase 8T、Hadoop Hive、Kingbase、Presto、SAP HANA、SAP Sybase、Spark、Transwarp Inceptor、Hbase等主流的一些关系型数据库及非关系数据库MongoDB等 5、可视化： 支持的图表类型多，达47种 图表可视化选项少，例如，数据格式选项偏少，如需添加，需要修改配置文件 可在看板中添加筛选框，支持在不同条件下查看 不支持图表和看板分组管理 没有提供图表的下钻功能，不支持多图表间的复杂联动 不支持跨库的表关联查询 6、支持文档： 安装部署和快速入门方面的文档详细，还有教学视频 但具体功能和图表制作方面的介绍文档几乎没有 7、邮件通知：支持 8、权限管理： 有一套完整的数据、业务包、报表、人员部门权限管理，有流程节点。 可实现数据源、数据表、字段、图表、看板等权限控制 9、二次开发： 不支持java层面的开发 只有web接口 能与.NET集成、JBPM工作流集成、CAS单点登录 10、源代码：不公开，商业产品团队运营。 DataV（阿里云）DataV旨让更多的人看到数据可视化的魅力，帮助非专业的工程师通过图形化的界面轻松搭建专业水准的可视化应用，满足您会议展览、业务监控、风险预警、地理信息分析等多种业务的展示需求。 1、配备多种场景模板 2、多种图表组件支持 3、支持多种数据源 4、配置比较快速灵活 Sugar（百度）连接地址： https://cloud.baidu.com/product/sugar.html 小马BI连接地址： https://xiaoma.qq.com/#/ 网易有数连接地址：https://bigdata.163yun.com/ 其它GitDataVgithub地址： https://github.com/HongqingCao/GitDataV GitDataV，是一个github“大数据可视化平台”，通过它你可以更直观的看到你在github里的一些数据：个人信息(✔)，仓库stars情况(✔)，仓库语言分类(✔)仓库公开数量(✔)、粉丝数量(✔)、跟随数量(✔)、仓库数据(✔)、最近你的操作(✔)最近的粉丝(✔)、最近的跟随(✔)、最新信息(✔)左上角箭头小彩蛋： 全屏(✔)、 国际化语言切换（✔）、返回首页（✔） DataVisualizationgithub地址： https://github.com/SimonZhangITer/DataVisualization 将数据通过图表的形式展现出来将大大的提升可读性和阅读效率 本例包含柱状图、折线图、散点图、热力图、复杂柱状图、预览面板等]]></content>
      <categories>
        <category>可视化工具</category>
        <category>Metabase</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端（iview）+后端（nodejs+koa2+sequelize）分离框架搭建]]></title>
    <url>%2F2019%2F09%2F05%2Fiview-koa2%2F</url>
    <content type="text"><![CDATA[后端源码：https://github.com/dumplingbao/dissplat 前端源码：https://github.com/dumplingbao/dissplat_web 概述iview：一套基于 Vue.js 的高质量UI 组件库，主流vue前端框架，比较适合前后端分离框架的搭建，当然你也可以选择其他的 koa2：基于nodejs平台的下一代web开发框架，这里我们不选早期的目前用的最多的Express，也不选阿里开源的框架egg，我们选择则目前比较新的koa2，写起来简单，也易于学习 sequelize：这个是个nodejs的ORM框架，用的比较多，关于这个框架的介绍，可以看一下我的另一篇博客，node之ORM框架。 搭建这个前后端分离的框架纯属娱乐加学习，写此博客就是把搭建过程介绍一下，也作为自己的一点心得吧。 后端-koa先找个轮子，这里用狼叔的koa-generator来生成项目架构 12npm install koa-generator -gkoa2 dissplat //项目名称 生成文档结构 1234567.├── bin├── public├── routes├── view├── package.json└── app.js 既然是轮子，直接就可以运行了 12npm installnpm run dev 系统自动创建users表 123(node:15140) [SEQUELIZE0002] DeprecationWarning: The logging-option should be either a function or false. Default: console.logExecuting (default): CREATE TABLE IF NOT EXISTS `users` (`id` INTEGER auto_increment , `nickname` VARCHAR(255), `email` VARCHAR(128) UNIQUE, `password` VARCHAR(255), `created_at` DATETIME, `updated_at` DATETIME NOT NULL, `deleted_at` DATETIME, PRIMARY KEY (`id`)) ENGINE=InnoDB;Executing (default): SHOW INDEX FROM `users` sequelize持久化ORM框架我们先按这个结构走，因为我们搭建前后端分离的框架，所以，public下面的图片、样式文件夹用不到，我们就把sequelize的model、dao、service、配置文件等放到public下面，删除public下面之前已有的文件 configpublic下面新建一个config文件夹，里面创建config.js，放数据库的配置信息 123456789module.exports = &#123;​ database: &#123;​ dbName: &apos;boblog&apos;,​ host: &apos;localhost&apos;,​ port: 3306,​ user: &apos;root&apos;,​ password: &apos;root&apos;​ &#125;&#125; db.js新建一个utils文件夹，创建一个db.js，我们简单封装，创建一个连接数据库的工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445const Sequelize = require(&apos;sequelize&apos;)const &#123;​ dbName,​ host,​ port,​ user,​ password&#125; = require(&apos;../config/config&apos;).databaseconst sequelize = new Sequelize(dbName, user, password, &#123;​ dialect: &apos;mysql&apos;,​ host,​ port,​ logging: true,​ timezone: &apos;+08:00&apos;,​ define: &#123;​ // create_time &amp;&amp; update_time​ timestamps: true,​ // delete_time​ paranoid: true,​ createdAt: &apos;created_at&apos;,​ updatedAt: &apos;updated_at&apos;,​ deletedAt: &apos;deleted_at&apos;,​ // 把驼峰命名转换为下划线​ underscored: true,​ scopes: &#123;​ bh: &#123;​ attributes: &#123;​ exclude: [&apos;password&apos;, &apos;updated_at&apos;, &apos;deleted_at&apos;, &apos;created_at&apos;]​ &#125;​ &#125;,​ iv: &#123;​ attributes: &#123;​ exclude: [&apos;content&apos;, &apos;password&apos;, &apos;updated_at&apos;, &apos;deleted_at&apos;]​ &#125;​ &#125;​ &#125;​ &#125;&#125;)// 创建模型sequelize.sync(&#123;​ force: false&#125;)module.exports = &#123;​ sequelize&#125; model接下来新建一个model文件夹，创建一个user.js，创建一个user的model 123456789101112131415161718192021222324252627282930313233343536373839404142const moment = require(&apos;moment&apos;);const bcrypt = require(&apos;bcryptjs&apos;)const &#123;Sequelize, Model&#125; = require(&apos;sequelize&apos;)const &#123;db&#125; = require(&apos;../utils/db&apos;)class User extends Model &#123;&#125;User.init(&#123; // attributes id: &#123; type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true &#125;, // 昵称 nickname: Sequelize.STRING, // 邮箱 email: &#123; type: Sequelize.STRING(128), unique: true &#125;, // 密码 password: &#123; type: Sequelize.STRING, set(val) &#123; // 加密 const salt = bcrypt.genSaltSync(10); // 生成加密密码 const psw = bcrypt.hashSync(val, salt); this.setDataValue(&quot;password&quot;, psw); &#125; &#125;, created_at: &#123; type: Sequelize.DATE, get() &#123; return moment(this.getDataValue(&apos;created_at&apos;)).format(&apos;YYYY-MM-DD&apos;); &#125; &#125;&#125;, &#123; db, modelName: &apos;users&apos; // options&#125;); dao接下来新建一个dao文件夹，创建一个user.js，创建一个user的dao，负责CRUD 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const &#123;User&#125; = require(&apos;../model/user&apos;)const bcrypt = require(&apos;bcryptjs&apos;)class UserDao &#123;​ // 创建用户​ static async createUser(v) &#123;​ const hasUser = await User.findOne(&#123;​ where: &#123;​ email: v.email,​ deleted_at: null​ &#125;​ &#125;);​ ​ if (hasUser) &#123;​ throw new global.errs.Existing(&apos;用户已存在&apos;);​ &#125;​ const user = new User();​ user.email = v.email;​ user.password = v.password;​ user.nickname = v.nickname;​ return user.save();​ &#125;​ // 验证密码​ static async verifyEmailPassword(email, plainPassword) &#123;​ // 查询用户是否存在​ const user = await User.findOne(&#123;​ where: &#123;​ email​ &#125;​ &#125;)​ if (!user) &#123;​ throw new global.errs.AuthFailed(&apos;账号不存在&apos;)​ &#125;​ // 验证密码是否正确​ const correct = bcrypt.compareSync(plainPassword, user.password);​ if (!correct) &#123;​ throw new global.errs.AuthFailed(&apos;密码不正确&apos;)​ &#125;​ return user​ &#125;​ // 删除用户​ static async destroyUser(id) &#123;​ const user = await User.findOne(&#123;​ where: &#123;​ id,​ deleted_at: null​ &#125;​ &#125;);​ if (!user) &#123;​ throw new global.errs.NotFound(&apos;没有找到此用户&apos;);​ &#125;​ user.destroy()​ &#125;​ // 获取用户详情​ static async getUserInfo(id) &#123;​ const user = await User.findOne(&#123;​ where: &#123;​ id​ &#125;​ &#125;);​ if (!user) &#123;​ throw new global.errs.NotFound(&apos;没有找到用户信息&apos;);​ &#125;​ return user​ &#125;​ // 更新用户​ static async updateUser(id, v) &#123;​ const user = await User.findByPk(id);​ if (!user) &#123;​ throw new global.errs.NotFound(&apos;没有找到用户信息&apos;);​ &#125;​ user.email = v.get(&apos;query.email&apos;);​ user.password = v.get(&apos;query.password2&apos;);​ user.nickname = v.get(&apos;query.nickname&apos;);​ user.save();​ &#125;​ static async getUserList(page = 1) &#123;​ const pageSize = 10;​ const user = await User.findAndCountAll(&#123;​ limit: pageSize,//每页10条​ offset: (page - 1) * pageSize,​ where: &#123;​ deleted_at: null​ &#125;,​ order: [​ [&apos;created_at&apos;, &apos;DESC&apos;]​ ]​ &#125;)​ return &#123;​ data: user.rows,​ meta: &#123;​ current_page: parseInt(page),​ per_page: 10,​ count: user.count,​ total: user.count,​ total_pages: Math.ceil(user.count / 10),​ &#125;​ &#125;;​ &#125;&#125;module.exports = &#123;​ UserDao&#125; 前端iview直接下载iview-admin项目DEMO 12345678# clone the projectgit clone https://github.com/iview/iview-admin.git// install dependenciesnpm install// developnpm run dev 123456789101112131415161718.├── config 开发相关配置├── public 打包所需静态资源└── src├── api AJAX请求└── assets 项目静态资源├── icons 自定义图标资源└── images 图片资源├── components 业务组件├── config 项目运行配置├── directive 自定义指令├── libs 封装工具函数├── locale 多语言文件├── mock mock模拟数据├── router 路由配置├── store Vuex配置├── view 页面文件└── tests 测试相关 效果图 菜单修改默认菜单读取routers.js，可以根据权限组控制，也可以根据权限读取菜单进行加载，菜单里面meta的配置说明如下，因为有些是路由，不显示在菜单里面，比如表单的CRUD操作。 123456789101112131415/** * iview-admin中meta除了原生参数外可配置的参数: * meta: &#123; * title: &#123; String|Number|Function &#125; * 显示在侧边栏、面包屑和标签栏的文字 * 使用&apos;&#123;&#123; 多语言字段 &#125;&#125;&apos;形式结合多语言使用，例子看多语言的路由配置; * 可以传入一个回调函数，参数是当前路由对象，例子看动态路由和带参路由 * hideInBread: (false) 设为true后此级路由将不会出现在面包屑中，示例看QQ群路由配置 * hideInMenu: (false) 设为true后在左侧菜单不会显示该页面选项 * notCache: (false) 设为true后页面在切换标签后不会缓存，如果需要缓存，无需设置这个字段，而且需要设置页面组件name属性和路由配置的name一致 * access: (null) 可访问该页面的权限数组，当前路由设置的权限会影响子路由 * icon: (-) 该页面在左侧菜单、面包屑和标签导航处显示的图标，如果是自定义图标，需要在图标名称前加下划线&apos;_&apos; * beforeCloseName: (-) 设置该字段，则在关闭当前tab页时会去&apos;@/router/before-close.js&apos;里寻找该字段名对应的方法，作为关闭前的钩子函数 * &#125; */ 简单构建登录将main.js里面的mock注释掉，mock拦截并模拟后台数据 123// 实际打包时应该不引入mock/* eslint-disable */// if (process.env.NODE_ENV !== &apos;production&apos;) require(&apos;@/mock&apos;) config.js配置baseUrl 1234567/** \* @description api请求基础路径 */ baseUrl: &#123;​ dev: &apos;http://localhost:8888/&apos;,​ pro: &apos;http://localhost:8888/&apos; &#125;, jwt获取token后端创建util.js 创建token 1234567891011121314151617const jwt = require(&apos;jsonwebtoken&apos;)const &#123;security&#125; = require(&apos;../config/config&apos;)// 颁布令牌const generateToken = function (uid, scope) &#123;​ const secretKey = security.secretKey;​ const expiresIn = security.expiresIn;​ const token = jwt.sign(&#123;​ uid,​ scope​ &#125;, secretKey, &#123;​ expiresIn: expiresIn​ &#125;)​ return token&#125;module.exports = &#123;​ generateToken,&#125; 前端请求过滤，请求加token验证，axios.js修改 1234if (!config.url.includes(&apos;/login&apos;)) &#123;​ // const base64 = Base64.encode(token + &apos;:&apos;);​ config.headers[&apos;Authorization&apos;] = &apos;Basic &apos; + Base64.encode(Cookies.get(TOKEN_KEY) + &apos;:&apos;)​ &#125; 后端采用basic-auth登录认证，见auth.js 跨域问题iview前端axios配置，找到axios.js配置文件 1234567891011 getInsideConfig () &#123;​ const config = &#123;​ baseURL: this.baseUrl,​ changeOrigin: true,​ headers: &#123;​ &apos;Content-Type&apos;: &apos;application/json; charset=utf-8&apos;,​ &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;​ &#125;​ &#125;​ return config &#125; 后端设置CORS来解决跨域问题，配置app.js，需要安装npm对应的包 12345678910111213141516const cors = require(&apos;@koa/cors&apos;);app.use(cors(&#123; origin: function (ctx) &#123;​ // if (ctx.url === &apos;/api&apos;) &#123;​ // return &quot;*&quot;; // 允许来自所有域名请求​ // &#125;​ // return &apos;http://localhost:8080&apos;;​ return &quot;*&quot;; // 允许来自所有域名请求 &#125;, exposeHeaders: [&apos;WWW-Authenticate&apos;, &apos;Server-Authorization&apos;], maxAge: 5, credentials: true, allowMethods: [&apos;OPTIONS&apos;,&apos;GET&apos;, &apos;PUT&apos;,&apos;POST&apos;, &apos;DELETE&apos;], //设置允许的HTTP请求类型 allowHeaders: [&apos;Origin&apos;, &apos;Content-Type&apos;, &apos;Accept&apos;, &apos;Access-Control-Allow-Origin&apos;, &apos;Authorization&apos;, &apos;X-Requested-With&apos;],&#125;)); 简单封装后端-util文件下 auth.js：访问认证 error.js：异常错误封装 help.js：请求封装 util.js：jwt获取token]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
        <tag>sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之ORM框架]]></title>
    <url>%2F2019%2F08%2F29%2Fnode-orm%2F</url>
    <content type="text"><![CDATA[概述写这篇blog的原因，想找个node的ORM框架用用，确很难找到一篇对比分析这些ORM框架的文章，唯一找到了一篇，居然是通过star数来论英雄，我觉着很难服众，于是就找几个看看。后来又不想分析，因为我发现node这种野蛮生长，滋生这些ORM轮子比比皆是，远比我想象的多；后来又觉着可以写，作为一个java出身业余研究node的就想通过java的ORM框架来洞悉node这群ORM框架的是非曲直，于是挑了几个框架小扯一篇。 ORM框架ORM框架：Object Relational Mapping，对象-关系-映射，所以说ORM框架就是用面向对象的方式和目前的关系型数据库做匹配，java开发者目前主流的hibernate、mybatis很熟悉了，JDBC原始驱动的方式想必也不在成为主流了。下面介绍几款node的ORM框架，介绍之前先介绍ORM的两种模式： Active Record 模式：活动记录模式，领域模型模式一个模型类对应关系型数据库中的一个表，模型类的一个实例对应表中的一行记录。这个不难理解，比较简单，但是不够灵活，再看另一种模式，比较一下 Data Mapper 模式：数据映射模式，领域模型对象和数据表是松耦合关系，只进行业务逻辑的处理，和数据层解耦。需要一个实体管理器来将模型和持久化层做对应，这样一来，灵活性就高，当然复杂性也增加了。 所以说，Data Mapper模式对业务代码干预少，Active Record模式直接在对象上CRUD，代码编写也更方便，这就像hibernate和mybatis两种框架，如果想深入研究，可以了解一下贫血与充血领域对象的平衡。 有这么一句话很认同，ActiveRecord更加适合快速开发成型的短期简单项目，而DataMapper更加适合长线开发，保持业务逻辑与数据存储独立的复杂项目。除此之外，技术选型还要考虑其他因素，比如项目历史背景等等。 TypeORMTypeORM 是一个 ORM 框架，详细介绍见 TypeORM 官方介绍，TypeORM 也借鉴了hibernate，所以你会发现它特别熟悉，尤其是装饰类的方式。 闲话少说，直接用CLI 命令快速构建项目 1npm install typeorm -g 创建项目 1typeorm init --name MyProject --database mysql name 是项目的名称，database 是将使用的数据库，TypeORM 支持多种数据库。 生成文档结构 1234567891011MyProject├── src // TypeScript 代码│ ├── entity // 存储实体（数据库模型）的位置│ │ └── User.ts // 示例 entity│ ├── migration // 存储迁移的目录│ └── index.ts // 程序执行主文件├── .gitignore // gitignore文件├── ormconfig.json // ORM和数据库连接配置├── package.json // node module 依赖├── README.md // 简单的 readme 文件└── tsconfig.json // TypeScript 编译选项 修改 ormconfig.json 数据库配置文件，直接运行就可以了 1npm start 看一下实体model，user类 123456789101112131415import &#123;Entity, PrimaryGeneratedColumn, Column&#125; from &quot;typeorm&quot;;@Entity()export class User &#123;​ @PrimaryGeneratedColumn()​ id: number;​ @Column()​ firstName: string;​ @Column()​ lastName: string;​ @Column()​ age: number;&#125; CRUD操作：逻辑层 1234567891011121314151617import &quot;reflect-metadata&quot;;import &#123;createConnection&#125; from &quot;typeorm&quot;;import &#123;User&#125; from &quot;./entity/User&quot;;createConnection().then(async connection =&gt; &#123;​ console.log(&quot;Inserting a new user into the database...&quot;);​ const user = new User();​ user.firstName = &quot;Timber&quot;;​ user.lastName = &quot;Saw&quot;;​ user.age = 25;​ await connection.manager.save(user);​ console.log(&quot;Saved a new user with id: &quot; + user.id);​ console.log(&quot;Loading users from the database...&quot;);​ const users = await connection.manager.find(User);​ console.log(&quot;Loaded users: &quot;, users);​ console.log(&quot;Here you can setup and run express/koa/any other framework.&quot;);&#125;).catch(error =&gt; console.log(error)); 所以，TypeORM的方式很像hibernate的方式，虽然es6中就已经有装饰器类似java的注解的功能了，但是还是和装饰器有所区别，因为TypeORM采用的是TypeScript 的方式，TypeScript 是 JavaScript 的一个超集，TypeScript 采用类型注解方式，虽然支持es6的标准，但是有些语法还是需要了解，这也或多或少增加了一些选择难度。 Sequelize这个被star数最多了一个ORM框架，官方居然不给中文文档，找个CLI命令快速构建也没有，也没找到个合适轮子，只能自己搭了，也不是少了轮子就不能活了。不过Sequelize的官网文档看着很顺眼，不得不称赞一下，需要注意的一点Sequelize v5版本发生了比较大的变化，这里我以最新版本v5版本为主，老版本可以自己看看下官方文档。Sequelize v5 安装npm包 12$ npm install --save sequelize$ npm install --save mysql2 数据库的配置文件config.js 123456789module.exports = &#123;​ database: &#123;​ dbName: &apos;TEST&apos;,​ host: &apos;localhost&apos;,​ port: 3306,​ user: &apos;root&apos;,​ password: &apos;123456&apos;​ &#125;&#125; 构建数据库访问公共文件db.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Sequelize = require(&apos;sequelize&apos;)const &#123;​ dbName,​ host,​ port,​ user,​ password&#125; = require(&apos;../config&apos;).databaseconst sequelize = new Sequelize(dbName, user, password, &#123;​ dialect: &apos;mysql&apos;,​ host,​ port,​ logging: true,​ timezone: &apos;+08:00&apos;,​ define: &#123;​ // create_time &amp;&amp; update_time​ timestamps: true,​ // delete_time​ paranoid: true,​ createdAt: &apos;created_at&apos;,​ updatedAt: &apos;updated_at&apos;,​ deletedAt: &apos;deleted_at&apos;,​ // 把驼峰命名转换为下划线​ underscored: true,​ scopes: &#123;​ bh: &#123;​ attributes: &#123;​ exclude: [&apos;password&apos;, &apos;updated_at&apos;, &apos;deleted_at&apos;, &apos;created_at&apos;]​ &#125;​ &#125;,​ iv: &#123;​ attributes: &#123;​ exclude: [&apos;content&apos;, &apos;password&apos;, &apos;updated_at&apos;, &apos;deleted_at&apos;]​ &#125;​ &#125;​ &#125;​ &#125;&#125;)// 创建模型sequelize.sync(&#123;​ force: false&#125;)module.exports = &#123;​ sequelize&#125; model 12345678910111213141516171819const &#123;Sequelize, Model&#125; = require(&apos;sequelize&apos;)const &#123;db&#125; = require(&apos;../../db&apos;)class User extends Model &#123;&#125;User.init(&#123; // attributes firstName: &#123; type: Sequelize.STRING, allowNull: false &#125;, lastName: &#123; type: Sequelize.STRING // allowNull defaults to true &#125;&#125;, &#123; db, modelName: &apos;user&apos; // options&#125;); 还有一种写法，兼容老版本，不推荐 12345678910111213const User = db.define(&apos;user&apos;, &#123; // attributes firstName: &#123; type: Sequelize.STRING, allowNull: false &#125;, lastName: &#123; type: Sequelize.STRING // allowNull defaults to true &#125;&#125;, &#123; // options&#125;); 这种实际上是sequelize.define内部调用了model.init，但是老版本是没有第一种写法的。 此外需要知道的是，sequelize还默认为每个模型定义字段id（主键）、createdat和updatedat，也可以进行设置。 我们的db.js文件里面配置了，不自动创建模型，也就是自动创建数据表，关闭是有原因的，因为如果表存在会先drop然后再创建，这种操作本身就很可怕的 1234// 创建模型sequelize.sync(&#123; force: false&#125;) 单个模型也可以配置，切记这种操作很危险，尤其是生成环境 12345678// Note: using `force: true` will drop the table if it already existsUser.sync(&#123; force: true &#125;).then(() =&gt; &#123; // Now the `users` table in the database corresponds to the model definition return User.create(&#123; firstName: &apos;John&apos;, lastName: &apos;Hancock&apos; &#125;);&#125;); CRUD操作：然后看一下逻辑层，就非常简单了，直接使用ES7 async/await即可 123456789101112131415161718192021222324// Find all usersUser.findAll().then(users =&gt; &#123; console.log(&quot;All users:&quot;, JSON.stringify(users, null, 4));&#125;);// Create a new userUser.create(&#123; firstName: &quot;Jane&quot;, lastName: &quot;Doe&quot; &#125;).then(jane =&gt; &#123; console.log(&quot;Jane&apos;s auto-generated ID:&quot;, jane.id);&#125;);// Delete everyone named &quot;Jane&quot;User.destroy(&#123; where: &#123; firstName: &quot;Jane&quot; &#125;&#125;).then(() =&gt; &#123; console.log(&quot;Done&quot;);&#125;);// Change everyone without a last name to &quot;Doe&quot;User.update(&#123; lastName: &quot;Doe&quot; &#125;, &#123; where: &#123; lastName: null &#125;&#125;).then(() =&gt; &#123; console.log(&quot;Done&quot;);&#125;); 由此来看，没有typeorm装饰类的方式看着顺眼，但是整体构造也容易上手，操作简单，容易理解，看官网文档，功能覆盖强大，typeorm用户反馈使用问题比Sequelize要多，后期用到再做比较。 ORM2ORM2貌似没有正了八经的官网，所以看起来就特别麻烦，但是可以看一下github介绍node-orm2，只支持四种数据库MySQL、PostgreSQL、Amazon Redshift、SQLite，这个我没写demo，直接分析一下 安装 1npm install orm 数据库连接 12345var orm = require(&quot;orm&quot;);orm.connect(&quot;mysql://username:password@host/database&quot;, function (err, db) &#123; // ...里面一些参数不详细写了&#125;); model 12345678var Person = db.define(&apos;person&apos;, &#123; name: String, surname: String, age: String, male: boolean&#125;, &#123; identityCache : true&#125;); CRUD操作 1234567891011121314151617Person.create([ &#123; name: &quot;John&quot;, surname: &quot;Doe&quot;, age: 25, male: true &#125;, &#123; name: &quot;Liza&quot;, surname: &quot;Kollan&quot;, age: 19, male: false &#125;], function (err, items) &#123; // err - description of the error or null // items - array of inserted items&#125;); 12345678910Person.get(1, function (err, John) &#123; John.name = &quot;Joe&quot;; John.surname = &quot;Doe&quot;; John.save(function (err) &#123; console.log(&quot;saved!&quot;); &#125;);//保存 Person.find(&#123; surname: &quot;Doe&quot; &#125;).remove(function (err) &#123; // Does gone.. &#125;);//删除&#125;); 12345678Person.find(&#123; name: &quot;admin&quot;&#125;) .limit(3) .offset(2)//跳过 .only(&quot;name&quot;, &quot;age&quot;)//返回字段 .run(function(err, data) &#123; &#125;); 所以，准确应该是node-orm2，写法和sequelize类似，但是文档确实不行，数据库支持也少，很难想象后续的可维护性。 其它 bookshelf（这个用的也挺多） persistencejs waterline mongoose node-mysql knex 。。。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成部署-Travis CI]]></title>
    <url>%2F2019%2F08%2F22%2Ftravis-ci%2F</url>
    <content type="text"><![CDATA[概述​ 对于一个程序猿来说，软件开发是本职工作，你会经常听到”发布到测试服务器测试一下“、”今晚弄完打个包发布到正式环境上“，你会发现集成部署已然成为程序员的必备技能，更何况还有转岗专门做实施的。 ​ 持续集成实际就是解决这些中间环节，自动化完成，就像构建、测试、集成类的工作，程序猿只需要提交代码剩下的活就自动干了。 ​ 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。（来自百度百科） ​ 持续集成部署工具： Gitlab CI Drone CI Jenkins Travis CI 这里不去介绍各自特点，有兴趣可以自己研究一下，只介绍一下Travis CI，市场份额最大的一个，不过好多人说是因为Travis CI绑定github的原因，所以也是主要说Travis CI结合github实现持续集成部署。 Travis CIgithub建两个分支：一个放源代码，一个放编译后的文件 这里以hexo搭建博客为例 设置GitHub_Token先到github上添加token 到Travis上添加token 配置Travis CI配置Travis CI实现自动编译发布 到Travis官网，进入设置，打开要发布的公开仓库 创建.travis.yml文件 1234567891011121314151617181920212223242526272829303132333435363738language: node_jsnode_js: stablecache: directories: - node_modulesbranches: only: - hexobefore_install: - npm install -g hexo-cli # S: Build Lifecycleinstall: - npm install - npm install hexo-deployer-git --save# before_script: # - npm install -g gulp script: - hexo clean - hexo generateafter_script:# - cd ./public# - git init - git config user.name &quot;gattia&quot; - git config user.email &quot;gattia.su@gmail.com&quot;# - git add .# - git commit -m &quot;Update docs&quot;# - git push --force --quiet &quot;$&#123;Travis&#125;@$&#123;GH_REF&#125;&quot; master:master - sed -i &quot;s/Travis/$&#123;Travis&#125;/g&quot; ./_config.yml - hexo deploy 注意部署路径，修改提交测试一下 发布完成 可以查看发布历史 点击项目右上角的build按钮，选择Markdown 将其复制到github项目下README中，图标开通成功 参考链接：https://segmentfault.com/a/1190000016603414?utm_source=tag-newest]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>travis ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手绘风格的图表库（char.xkcd）]]></title>
    <url>%2F2019%2F08%2F20%2Fchar-xkcd%2F</url>
    <content type="text"><![CDATA[概述chart.xkcd 手绘风格图表库，是透明创业实验第十四周发布的产品，关于这个透明创业实验是一个毕业研究生，一个不想让企业拿钱买自己时间的全干工程师，辞职一年搞实验（羡慕），大家有兴趣可以关注一下。 ​ 首先是关注这个实验，所以了解到这个产品亦或者说是个轮子，其次图表展示这种日常工作中也会用到，主要是关心这个产品实现方式和探究它的价值。 产品价值仅代表个人观点： 我们用的多的如：百度的echarts、hcharts以及阿里那种可视化工具，功能强大、上手容易，这种手绘风格应该没有，所以差异化和特点具有吸引力 企业和厂家这种风格不太适合，对于一般的尤其是个人网站，用这种风格还是比较有新意 创意的突破总能令人赏心悦目，或许能激发更多的灵感 浅析原理 [xkcd]: https://xkcd.com/ “风格” D3.js 滤镜filter xkcd风格xkcd是兰道尔·门罗（Randall Munroe）的网名，又是他所创作的漫画的名称。作者兰道尔·门罗（Randall Munroe）给作品的定义是一部“关于浪漫、讽刺、数学和语言的网络漫画”(A webcomic of romance,sarcasm, math, and language)，被网友誉为深度宅向网络漫画。 D3.jsD3 的全称是（Data-Driven Documents），顾名思义可以知道是一个被数据驱动的文档。听名字有点抽象，说简单一点，其实就是一个 JavaScript 的函数库，使用它主要是用来做数据可视化的 滤镜filterSVG使用&lt;filter&gt;元素来定义滤镜 12345678910&lt;filterfilterUnits=&quot;units to define filter effect region&quot;primitiveUnits=&quot;units to define primitive filter subregion&quot;x=&quot;x-axis co-ordinate&quot; y=&quot;y-axis co-ordinate&quot; width=&quot;length&quot;height=&quot;length&quot;filterRes=&quot;numbers for filter region&quot;xlink:href=&quot;reference to another filter&quot; &gt;&lt;/filter&gt; ​添加属性 12&lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot;fill=&quot;green&quot; filter=&quot;url(#filter1)&quot; /&gt; 正式利用这种方式，增加滤镜处理，后续也容易实现自定义和切换风格 简单介绍，后续会持续关注和更新。。。]]></content>
      <categories>
        <category>可视化工具</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>透明创业实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BLOG】hexo搭建blog教程]]></title>
    <url>%2F2019%2F08%2F16%2Fhexo-createDemo%2F</url>
    <content type="text"><![CDATA[概述特点： nodejs生成搭建快速 支持markdown git一键部署 插件丰富，生态完善 环境准备建议使用vscode编辑器，依据个人喜好而定。 安装nodejs 安装git 安装hexo 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 文档结构 12345678910.├── node_modules├── scaffolds├── source| └── _posts├── themes├── _config.yml├── package.json├── package-lock.json└── yarn.lock 启动 1$ hexo server 访问地址 http://localhost:4000/ 本地blog搭建完成 常用命令 生成静态文件 1$ hexo generate 简写 1$ hexo g 参数 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 清除缓存文件（更换主题等操作使用） 1$ hexo clean 发布部署 1$ hexo deploy 简写 1$ hexo d 参数 描述 -g, --generate 部署之前预先生成静态文件 其他命令，见hexo: https://hexo.io 官网 主题设置hexo: https://hexo.io 官网上有很多主题，这里我们采用 主题 在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next Live 2D模型插件安装npm包 1npm install --save hexo-helper-live2d 在hexo的站点配置文件_config.yml中添加如下配置 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-模型名称 display: position: right width: 150 height: 300 mobile: show: true 下载模型 1npm install live2d-widget-model-模型名称 模型列表： live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-hibikilive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 来必力评论插件登录来必力注册账号，在代码管理里面找到 data-uid。 到主题配置文件_config.yml里，添加 livere_uid。 备注：如果想取消某个页面的评论，在文章属性中增加comments：false即可 DaoVoice在线聊天插件首先需要注册一个 DaoVoice，点击注册 应用设置》安装到网站 以 next 主题为例，打开 themes/next/layout/_partials/head.swig 文件中添加代码，位置随意： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 可以在DaoVoice官网上，设置按钮，绑定微信等操作 在主题配置文件 _config.yml，添加如下代码： 123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 搜索服务插件安装 hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 站点配置文件，增加如下内容 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件，启用搜素功能 123# Local searchlocal_search: enable: true 百度统计插件登录百度统计 ，添加站点，获取代码，找到ID 1hm.src = &quot;https://hm.baidu.com/hm.js?百度统计ID&quot;; 主题配置文件themes/*/_config.yml，修改字段 google_analytics 12# Baidu Analytics IDbaidu_analytics: 百度统计ID 百度分享 百度分享服务，主题配置文件，修改字段 baidushare，值为 true即可。 12345# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: true need-more-share2 主题配置文件，修改字段 needmoreshare2，值为 true即可 12needmoreshare2: enable: true RSS配置1简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能`直接被其他站点调用`，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。——百度百科 安装hexo-generator-feed 1$ npm install --save hexo-generator-feed 站点配置文件 ，Extensions，添加配置 123# Extensions## Plugins: https://hexo.io/plugins/Plugins: hexo-generate-feed 主题配置文件，字段rss，添加配置 1rss: /atom.xml 具体内容需要烧制feed 侧边栏会生成一个RSS图标 部署发布你可以自己搭建服务器部署，但是会很麻烦，这里我们可以采用主流git代码托管网站里发布自己的blog github page coding 码云备注：README的问题 第一：执行命令hexo g之后，会把source文件里的.md格式的文件渲染为html文件并放到public下面 第二：执行命令hexo d之后，会把public下面的所有文件放到.deploy_git并提交到对应的github这个仓库 第三：hexo进行渲染文件时渲染不到README文件，所有就进不到部署路径里面 解决办法： 我们在本地的source文件里新建一个README.md文件。 修改Hexo根目录下的_config.yml文件，将skip_render参数的值设置为README.md 1skip_render: README.md Travis CI​ Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。我们在软件开发过程中，有构建、测试、部署这些必不可少的步骤，而这些会花掉我们很多的时间。为了提高软件开发的效率，现在涌现了很多自动化工具。Travis CI 是目前市场份额最大的一个，而且有很详细的文档以及可以和 Github 很好的对接。 ​ 详见我的blog文章。 更换hexo网页图标制作favicon图标 准备图片 搜索favicon 在线，在线图片转favicon的工具，推荐使用： bitbug 生成图标16x16，32x32两种。 在主题配置文件themes/*/_config.yml修改 ```favicon:small: /images/favicon-16x16-next.icomedium: /images/favicon-32x32-next.ico]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
